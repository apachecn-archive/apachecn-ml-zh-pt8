<html><head/><body>
<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>R and SQL Server 2016/2017 Features Extended</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4MLOS0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">r和SQL Server 2016/2017功能扩展</h1>
                
            
            
                
<p class="calibre2">SQL Server 2016和2017提供了许多新的和改进的查询性能功能、可扩展性功能、安全功能和内置/原生功能，对开发人员、数据库管理员和数据科学家非常有用。这些新特性和功能可以与SQL中的机器学习服务一起使用，带来强大的数据科学解决方案，并使开发人员/数据科学家的生活更加轻松。<br class="title-page-name"/></p>
<p class="calibre2">本章将通过几个独特的场景向您展示R和SQL Server中其他内置功能的组合威力。这些场景包括JSON内置的功能来展示我们如何处理物联网数据，PolyBase来说明关系数据源以外的内容，以及大量带有<kbd class="calibre11">ColumnStore</kbd>索引的数据。我们将深入这些场景，并在R中产生我们在前面章节中学到的数据可视化和预测分析能力。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Built-in JSON capabilities</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4NK9E0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">内置的JSON功能</h1>
                
            
            
                
<p class="calibre2">在这个场景中，我们将使用奥斯汀市官方开放数据门户网站(<a href="https://data.austintexas.gov/Public-Safety/EMS-Incidents-by-Month/gjtj-jt2d" class="calibre10">https://data . Austin Texas . gov/Public-Safety/EMS-Incidents-by-Month/gjtj-jt2d</a>)中按月统计的EMS事件。该数据主要包含奥斯汀市和特拉维斯县事故的地点和优先级细分的事故计数，以及按时合规的百分比。</p>
<p class="calibre2">以下是入门的先决条件:</p>
<ol class="calibre14">
<li value="1" class="calibre8">从<a href="https://data.austintexas.gov/resource/bpws-iwvb.json" class="calibre10">https://data.austintexas.gov/resource/bpws-iwvb.json</a>下载数据到本地路径，比如<kbd class="calibre11">C:\Temp\bpws-iwvb.json</kbd>。</li>
<li value="2" class="calibre8">授予对目录的读取权限；例如:</li>
</ol>
<div><img class="aligncenter104" src="img/00178.jpeg"/></div>
<p>图10.1授予MS SQL Server对C:\Temp的访问权限</p>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">为了便于可视化，我们将使用SQL Operations Studio。可以从:<a href="https://docs.microsoft.com/en-us/sql/sql-operations-studio/download" target="_blank" class="calibre10">https://docs . Microsoft . com/en-us/SQL/SQL-operations-Studio/download</a>下载SQL Ops Studio。</li>
</ol>
<p class="calibre34">以下是JSON文件的摘录:</p>
<div><img src="img/00179.jpeg" class="calibre27"/></div>
<p>图10.2:bpws-iwvb . JSON的摘录</p>
<p class="calibre34">这个文件中JSON对象的模式相当简单。它是以下31个属性的数组:</p>
<ul class="calibre7">
<li class="front-matter">
 
</li>
</ul>
<p class="calibre34">若要查看数据的第一行以及值的样子，可以使用以下T-SQL代码:</p>
<pre class="calibre33"><strong class="calibre1">SELECT * 
FROM OPENJSON((SELECT Doc.BulkColumn  
                FROM OPENROWSET(BULK N'C:\Temp\bpws-iwvb.json', SINGLE_CLOB) AS Doc), '$[0]')</strong> </pre>
<p class="calibre34">以下是前面命令的输出:</p>
<div><img class="aligncenter105" src="img/00180.jpeg"/></div>
<p>图10.3检查bpws-iwvb.json中的第一行数据</p>
<p class="calibre2">本节的剩余部分将向您展示如何使用SQL Server中内置的JSON和R功能来解析数据并创建可视化，以了解ATCEMS收到的EMS事件的趋势。下面的屏幕截图显示了我们将通过SQL Operations Studio从前面的JSON数据构建的数据可视化:</p>
<div><img src="img/00181.jpeg" class="calibre94"/></div>
<p>图10.4使用R预测EMS事故</p>
<p class="calibre2">执行以下步骤来构建前面的可视化:</p>
<ol class="calibre14">
<li value="1" class="calibre8">打开SQL Operations Studio。</li>
<li value="2" class="calibre8">使用JSON，获得<kbd class="calibre11">Date</kbd>和事件计数:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">SELECT  
    a.Date,  
    a.TotalIncidents, 
    a.AustinIncidents, 
    a.TravisIncidents 
FROM OPENJSON((SELECT Doc.BulkColumn  
                FROM OPENROWSET(BULK N'C:\Temp\bpws-iwvb.json', SINGLE_CLOB) AS Doc), '$') 
WITH (Date          DATE    '$.month_start_date', 
    TotalIncidents  INT     '$.count_incidents_all', 
    AustinIncidents INT     '$.count_incidents_coa', 
    TravisIncidents INT     '$.count_incidents_tc' 
    ) AS a 
ORDER BY a.Date ASC;</strong></pre>
<p class="calibre34">这里，我们使用<kbd class="calibre11">OPENROWSET</kbd>和<kbd class="calibre11">SINGLE_CLOB</kbd>以明文读取文件流。</p>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">然后，我们用<kbd class="calibre11">OPEN_JSON</kbd>提取<kbd class="calibre11">month_start_date</kbd>为<kbd class="calibre11">Date</kbd>、<kbd class="calibre11">count_incidents_all</kbd>为<kbd class="calibre11">TotalIncidients</kbd>、<kbd class="calibre11">count_incidents_coa</kbd>为<kbd class="calibre11">AustinIncidents</kbd>、<kbd class="calibre11">count_incidents_tc</kbd>为<kbd class="calibre11">TravisIncidents</kbd>。</li>
</ol>
<p class="calibre34">输出应该如下所示:</p>
<div><img class="aligncenter106" src="img/00182.jpeg"/></div>
<p>图10.5:对EMS事件JSON文件运行OPENJSON的输出</p>
<ol start="4" class="calibre14">
<li value="4" class="calibre8">现在，让我们用<kbd class="calibre11">Date</kbd>和<kbd class="calibre11">TotalIncidents</kbd>数据为R脚本构建<kbd class="calibre11">InputDataSet</kbd>:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">DECLARE @input_query    NVARCHAR(MAX);  
SET @input_query = 'SELECT  
    a.Date,  
    a.TotalIncidents 
FROM OPENJSON((SELECT Doc.BulkColumn  
    FROM OPENROWSET(BULK N'C:\Temp\bpws-iwvb.json',  
         SINGLE_CLOB) AS Doc), '$') 
   WITH (Date            DATE  '$.month_start_date', 
         TotalIncidents  INT   '$.count_incidents_all' 
        ) AS a;' </strong></pre>
<ol start="5" class="calibre14">
<li value="5" class="calibre8">让我们构建使用前面的<kbd class="calibre11">InputDataSet</kbd>的R脚本:</li>
</ol>
<p class="calibre34">在此脚本中，我们将使用预测包根据2010年1月和2017年11月的现有数据执行预测。有关预测包(包括相关包)的更多信息，请访问:<a href="https://cran.r-project.org/web/packages/forecast/index.html" class="calibre10">https://cran.r-project.org/web/packages/forecast/index.html</a>。</p>
<p class="calibre34">在这个具体的例子中，事件的数量可以是季节性的。因此，我们将使用一些有助于预测的辅助功能:</p>
<ul class="calibre7">
<li class="front-matter">
 
</li>
</ul>
<pre class="calibre33"><strong class="calibre1">DECLARE @RPlot          NVARCHAR(MAX); 
 
SET @RPlot = 'library(forecast); 
    image_file = tempfile();  
    jpeg(filename = image_file, width=1000, height=400);  
 
    #store as time series  
    myts &lt;- ts(InputDataSet$TotalIncidents,  
        start = c(2010, 1), end = c(2017, 11), 
         frequency = 12);  
    fit &lt;- stl(myts, s.window = "period"); 
 
    # show the plot 
    plot(forecast(fit), main = "Forecast of EMS incidents"); 
    dev.off();  
 
    # return the plot as dataframe 
    OutputDataSet &lt;-  data.frame( 
        data=readBin(file(image_file,"rb"), 
        what=raw(),n=1e6));'</strong> </pre>
<ol start="6" class="calibre14">
<li value="6" class="calibre8">现在，让我们执行以下脚本:</li>
</ol>
<pre class="calibre95"><strong class="calibre1">EXEC sp_execute_external_script @language = N'R' 
    ,@script = @RPlot  
    ,@input_data_1 = @input_query 
    ,@input_data_1_name = N'InputDataSet' 
    ,@output_data_1_name = N'OutputDataSet'  
    WITH RESULT SETS (( [plot] VARBINARY(MAX)));</strong>     </pre>
<ol start="7" class="calibre14">
<li value="7" class="calibre8">在SQL Ops Studio中，结果将在<kbd class="calibre11">VARBINARY</kbd>数据类型中:</li>
</ol>
<div><img src="img/00183.jpeg" class="calibre96"/></div>
<p>图10.6:SQL Operations Studio中的查看图表功能</p>
<ol start="8" class="calibre14">
<li value="8" class="calibre8">单击右侧的查看图表图标，然后单击结果窗格上的图表查看器选项卡，然后从图表类型中选择图像。输出应该类似于以下内容:</li>
</ol>
<div><img class="aligncenter107" src="img/00184.jpeg"/></div>
<p>图10.7:在SQL Operations Studio中显示R生成的图表</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Accessing external data sources using PolyBase</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4OIQ00-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">使用PolyBase访问外部数据源</h1>
                
            
            
                
<p class="calibre2">PolyBase允许您的SQL Server实例使用T-SQL访问服务器/数据库之外的数据。在SQL Server 2016中，您可以在Hadoop中对外部数据运行查询，或者从Azure Blob存储中导入数据:</p>
<div><img class="aligncenter108" src="img/00185.jpeg"/></div>
<p>图10.8: PolyBase概念(来源:https://docs . Microsoft . com/en-us/SQL/relational-databases/poly base/poly base-guide)</p>
<p class="calibre2">在本节中，我们将使用与上一节类似的数据集，在Azure Blob存储中表示为CSV文件。这些CSV文件代表EMS事件，这些事件将作为SQL Server中的外部表公开。本演练的目标是了解EMS事件的季节性和趋势。我们将在SQL Server中使用R来完成这项工作，并在SQL Operations Studio中查看图表。</p>
<p class="calibre2">以下是入门的先决条件:</p>
<ol class="calibre14">
<li value="1" class="calibre8">与PolyBase一起安装的SQL Server实例。该步骤记录在:<a href="https://docs.microsoft.com/en-us/sql/relational-databases/polybase/get-started-with-polybase" target="_blank" class="calibre10">https://docs . Microsoft . com/en-us/SQL/relational-databases/poly base/get-started-with-poly base</a></li>
<li value="2" class="calibre8">已安装Microsoft Azure存储资源管理器。使用Azure存储资源管理器，您可以上传文件，管理您的存储帐户中的容器，并从存储帐户获取主访问密钥:</li>
</ol>
<div><img src="img/00186.jpeg" class="calibre97"/></div>
<p>图10.9:使用Microsoft Azure存储资源管理器连接到Azure Blob存储</p>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">按月EMS事件从<insert github="" link="">下载并上传到您的Azure Blob存储。</insert></li>
<li value="4" class="calibre8">已安装SSMS或SQL Operations Studio。</li>
</ol>
<p class="calibre2">执行以下步骤创建外部表:</p>
<ol class="calibre14">
<li value="1" class="calibre8">启用高级选项以首先启用到master数据库上Azure Blob存储的连接。</li>
</ol>
<p class="calibre34">将Hadoop连接性设置为7允许连接到Azure Blob存储。有关其他受支持数据源的更多信息，请访问:</p>
<p class="calibre34"><a href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/polybase-connectivity-configuration-transact-sql" target="_blank" class="calibre10">https://docs . Microsoft . com/en-us/SQL/database-engine/configure-windows/poly base-connectivity-configuration-transact-SQL</a></p>
<pre class="calibre33"><strong class="calibre1">USE master;   
GO   
EXEC sp_configure 'show advanced option', '1';   
RECONFIGURE;  
GO 
EXEC sp_configure 'hadoop connectivity', 7;  
GO  
RECONFIGURE;  
GO</strong> </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">在您的数据库中创建一个主密钥，您希望在该数据库中创建一个连接到Azure Blob存储中的CSV文件的外部表:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">USE [AdventureWorks2016] 
GO 
CREATE MASTER KEY ENCRYPTION BY PASSWORD='MsSQLGirlLovesSQLServer2016&amp;2017:)';</strong> </pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">创建数据库<kbd class="calibre11">MsSQLGirlAtAzureBlobStorage</kbd>:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE DATABASE SCOPED CREDENTIAL MsSQLGirlAtAzureBlobStorage   
WITH IDENTITY = 'credential', Secret = 'Es3duvq+x9G5x+EFbuUmGo0salEi6Jsd59NI20KXespbiBG9RswLA4L1fuqs/59porPBay64YkRj/tvQ7XAMLA=='; </strong></pre>
<ol start="4" class="calibre14">
<li value="4" class="calibre8">创建指向Azure Blob存储中的容器的外部数据源。在这个实例中，<kbd class="calibre11">open-data-sample</kbd>是容器的名称，<kbd class="calibre11">mssqlgirl.blob.core.windows.net</kbd>是Azure Blob存储位置:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE EXTERNAL DATA SOURCE OpenDataSample 
WITH ( 
    TYPE = HADOOP, 
    LOCATION = 'wasbs://open-data-sample@mssqlgirl.blob.core.windows.net/', 
    CREDENTIAL = MsSQLGirlAtAzureBlobStorage 
);</strong> </pre>
<ol start="5" class="calibre14">
<li value="5" class="calibre8">在容器中创建源文件的文件格式:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE EXTERNAL FILE FORMAT csvformat  
WITH (  
    FORMAT_TYPE = DELIMITEDTEXT,  
    FORMAT_OPTIONS (  
        FIELD_TERMINATOR = ',' 
    )  
);</strong> </pre>
<ol start="6" class="calibre14">
<li value="6" class="calibre8">在容器中创建以下源文件:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE EXTERNAL TABLE EMSIncident 
(  
   [Month Key]                         INT, 
   [Month-Year]                        VARCHAR(30), 
   [Total Incidents]                   INT, 
   [Austin Incidents]                  INT, 
   [Travis County Incidents]           INT, 
   [Other Area Incidents]              INT, 
   [Combined Austin &amp; Travis Incidents]      INT, 
   [Austin P1 Incidents]               INT, 
   [Austin P2 Incidents]               INT, 
   [Austin P3 Incidents]               INT, 
   [Austin P4 Incidents]               INT, 
   [Austin P5 Incidents]               INT, 
   [Travis County P1 Incidents]        INT, 
   [Travis County P2 Incidents]        INT, 
   [Travis County P3 Incidents]        INT, 
   [Travis County P4 Incidents]        INT, 
   [Travis County P5 Incidents]        INT, 
   [Overall On-Time Compliance]        VARCHAR(10), 
   [Austin On-Time Compliance]               VARCHAR(10), 
   [Travis County On-Time Compliance]        VARCHAR(10), 
   [Austin P1 On-Time Compliance]            VARCHAR(10), 
   [Austin P2 On-Time Compliance]            VARCHAR(10), 
   [Austin P3 On-Time Compliance]            VARCHAR(10), 
   [Austin P4 On-Time Compliance]            VARCHAR(10), 
   [Austin P5 On-Time Compliance]            VARCHAR(10), 
   [Travis County P1 On-Time Compliance]     VARCHAR(10), 
   [Travis County P2 On-Time Compliance]     VARCHAR(10), 
   [Travis County P3 On-Time Compliance]     VARCHAR(10), 
   [Travis County P4 On-Time Compliance]     VARCHAR(10), 
   [Travis County P5 On-Time Compliance]     VARCHAR(10), 
   [Target On-Time Compliance]               VARCHAR(10) 
)  
WITH  
(  
    LOCATION = '/EMS_-_Incidents_by_Month.csv',  
    DATA_SOURCE = OpenDataSample,  
    FILE_FORMAT = csvformat  
)</strong> </pre>
<ol start="7" class="calibre14">
<li value="7" class="calibre8">所以，现在我们可以在外部表上做一个<kbd class="calibre11">SELECT</kbd>语句作为R脚本的输入:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">DECLARE @input_query    NVARCHAR(MAX);  
DECLARE @RPlot          NVARCHAR(MAX); 
 
SET @input_query = 'SELECT  
    CAST([Month-Year] AS DATE) AS [Date], 
    [Total Incidents] AS [TotalIncidents] 
FROM EMSIncident;' 
SET @RPlot = 'library(ggplot2);  
    library(forecast); 
    image_file = tempfile();  
    jpeg(filename = image_file, width=1000, height=400);  
 
    #store as time series  
    myts &lt;- ts(InputDataSet$TotalIncidents,  
        start = c(2010, 1), end = c(2017, 11), 
         frequency = 12);  
    fit &lt;- stl(myts, s.window = "period"); 
    
    # show the plot 
    plot(fit, main = "EMS incidents"); 
    dev.off();  
 
    # return the plot as dataframe 
    OutputDataSet &lt;-  data.frame( 
        data=readBin(file(image_file,"rb"), 
        what=raw(),n=1e6));' 
 
 
EXEC sp_execute_external_script @language = N'R' 
    ,@script = @RPlot  
    ,@input_data_1 = @input_query 
    ,@input_data_1_name = N'InputDataSet' 
    ,@output_data_1_name = N'OutputDataSet'  
    WITH RESULT SETS (( [plot] VARBINARY(MAX)));     </strong></pre>
<p class="calibre2">如果您使用的是SQL Operations Studio，您可以查看该图，它应该如下所示:</p>
<div><img class="aligncenter109" src="img/00187.jpeg"/></div>
<p>图10.10: EMS事件时间序列</p>
<p class="calibre2">上图表明，从2010年到2016年，趋势是上升的，然后总体上显著下降。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>High performance using ColumnStore and in memory OLTP</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4PHAI0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">使用列存储和内存OLTP实现高性能</h1>
                
            
            
                
<p class="calibre2">SQL Server 2016 R服务和SQL Server 2017 ML服务提供了高级分析功能，这些功能也可以应用于优化的表。在本节中，我们将带您比较如何使用R服务:</p>
<ul class="calibre7">
<li class="calibre8">带有主键的表</li>
<li class="calibre8">具有聚集的<kbd class="calibre11">ColumnStore</kbd>索引的表</li>
<li class="calibre8">内存优化表</li>
<li class="calibre8">带有聚集的<kbd class="calibre11">ColumnStore</kbd>索引的内存优化表</li>
</ul>
<p>有关SQL Server和机器学习的更多优化提示和技巧，请访问:<br class="calibre30"/><a href="https://azure.microsoft.com/en-us/blog/optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services/" target="_blank" class="calibre40">https://azure . Microsoft . com/en-us/blog/optimization-tips-and-tricks-on-azure-SQL-Server-for-machine-learning-services/</a></p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Testing rxLinMod performance on a table with a primary key</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4QFR40-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">在带有主键的表上测试rxLinMod性能</h1>
                
            
            
                
<p class="calibre2">下面的步骤将测试<kbd class="calibre11">rxLinMod</kbd>在存储在一个带有主键的表中的6096762位数据上的性能。该航空航班数据可从<a href="https://packages.revolutionanalytics.com/datasets/AirOnTime2012.xdf" class="calibre10">https://packages . revolution analytics . com/datasets/airontime 2012 . xdf</a>下载并存储在<kbd class="calibre11">C:/Program Files/Microsoft SQL Server/140/R_SERVER/library/RevoScaleR/SampleData</kbd>中。在步骤结束时，我们将记录CPU时间:</p>
<ol class="calibre14">
<li value="1" class="calibre8">创建一个存储过程来读取XDF文件中的<kbd class="calibre11">AirFlights</kbd>样本数据，并将其作为数据帧返回，以便我们可以将其插入到一个新表中:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE PROCEDURE [dbo].[usp_ImportXDFtoSQL] 
AS 
   DECLARE @RScript NVARCHAR(MAX) 
   SET @RScript = N'library(RevoScaleR) 
         rxOptions(sampleDataDir = "C:/Program Files/Microsoft SQL Server/140/R_SERVER/library/RevoScaleR/SampleData"); 
         outFile &lt;-  file.path(rxGetOption("sampleDataDir"), "AirOnTime2012.xdf"); 
         OutputDataSet &lt;- data.frame(rxReadXdf(file=outFile, varsToKeep=c("ArrDelay", "CRSDepTime","DayOfWeek")))' 
 
   EXECUTE sp_execute_external_script 
          @language = N'R' 
         ,@script = @RScript 
         WITH RESULT SETS (( 
               [ArrDelay]        SMALLINT, 
               [CRSDepTime]      DECIMAL(6,4), 
               [DayOfWeek]       NVARCHAR(10))); 
GO</strong></pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">创建一个存储<kbd class="calibre11">AirFlights</kbd>数据的表格。此表代表一个带有主键的行存储表:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE TABLE [dbo].[AirFlights] 
( 
    [ID]             INT NOT NULL IDENTITY(1,1)  
   ,[ArrDelay]       SMALLINT 
   ,[CRSDepTime]     DECIMAL(6,4) 
   ,[DayOfWeek]      NVARCHAR(10)  
   ,CONSTRAINT PK_AirFlights PRIMARY KEY ([ID]) 
); 
GO </strong></pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">将航班数据插入<kbd class="calibre11">AirFlights</kbd>表中。在这个实例中，我们使用R服务来加载数据:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">INSERT INTO [dbo].[AirFlights] 
EXECUTE [dbo].[usp_ImportXDFtoSQL]</strong> </pre>
<ol start="4" class="calibre14">
<li value="4" class="calibre8">创建一个调用外部脚本的过程，根据到达延迟的线性模型预测来计算系数:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE PROCEDURE dbo.usp_TestPerformance (@TableName VARCHAR(50)) 
AS 
   DECLARE @RScript NVARCHAR(MAX) 
   SET @RScript = N'library(RevoScaleR) 
                           LMResults &lt;- rxLinMod(ArrDelay ~ DayOfWeek, data = InputDataSet) 
                           OutputDataSet &lt;- data.frame(LMResults$coefficients)' 
 
   DECLARE @SQLScript nvarchar(max) 
   SET @SQLScript = N'SELECT ArrDelay, DayOfWeek FROM ' + @TableName  
   SET STATISTICS TIME ON; 
   EXECUTE sp_execute_external_script 
          @language = N'R' 
         ,@script = @RScript 
         ,@input_data_1 = @SQLScript 
   WITH RESULT SETS (( 
                     Coefficient DECIMAL(10,5) 
                     )); 
 
   SET STATISTICS TIME OFF; 
GO</strong> </pre>
<ol start="5" class="calibre14">
<li value="5" class="calibre8">执行该过程，如下所示:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">EXEC dbo.usp_TestPerformance '[dbo].[AirFlights]'</strong> </pre>
<p class="calibre34">结果应该是这样的:</p>
<pre class="calibre33"><strong class="calibre1">SQL Server parse and compile time:  
   CPU time = 0 ms, elapsed time = 1 ms. 
STDOUT message(s) from external script:  
Rows Read: 6096762, Total Rows Processed: 6096762, Total Chunk Time: 0.075 seconds  
Computation time: 0.080 seconds. 
(8 rows affected) 
 SQL Server Execution Times: 
   CPU time = 2797 ms,  elapsed time = 10463 ms. 
 SQL Server Execution Times: 
   CPU time = 2797 ms,  elapsed time = 10464 ms.</strong> </pre>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Testing rxLinMod performance on a table with a clustered ColumnStore index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4REBM0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">在具有聚集列存储索引的表上测试rxLinMod性能</h1>
                
            
            
                
<p class="calibre2">下面的步骤将测试存储在带有聚集索引的表中的6，096，762位数据的性能。在步骤结束时，我们将记录CPU时间:</p>
<ol class="calibre14">
<li value="1" class="calibre8">创建一个类似于上一节中的<kbd class="calibre11">dbo.AirFlights</kbd>的表格。我们还想创建一个聚集的<kbd class="calibre11">ColumnStore</kbd>索引，并插入来自<kbd class="calibre11">dbo.AirFlights</kbd>的数据:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE TABLE AirFlights_CS 
( 
    [ID]             INT NOT NULL IDENTITY(1,1) 
   ,[ArrDelay]       SMALLINT 
   ,[CRSDepTime]     DECIMAL(6,4) 
   ,[DayOfWeek]      NVARCHAR(10)  
); 
GO 
 
INSERT INTO [dbo].[AirFlights_CS] 
( 
    [ArrDelay]        
   ,[CRSDepTime]      
   ,[DayOfWeek]       
) 
SELECT  
    [ArrDelay]        
   ,[CRSDepTime]      
   ,[DayOfWeek]       
FROM [dbo].[AirFlights];  
GO 
 
CREATE CLUSTERED COLUMNSTORE INDEX CCI_Airflights_CS ON [dbo].[AirFlights_CS]  
GO</strong> </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">执行以下程序:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">EXEC dbo.usp_TestPerformance '[dbo].[AirFlights_CS]'</strong> </pre>
<p class="calibre34">结果应该如下所示:</p>
<pre class="calibre33"><strong class="calibre1">SQL Server parse and compile time:  
   CPU time = 0 ms, elapsed time = 7 ms. 
STDOUT message(s) from external script:  
Rows Read: 6096762, Total Rows Processed: 6096762, Total Chunk Time: 0.075 seconds  
Computation time: 0.080 seconds. 
(8 rows affected) 
 SQL Server Execution Times: 
   CPU time = 2235 ms,  elapsed time = 10684 ms. 
 SQL Server Execution Times: 
   CPU time = 2235 ms,  elapsed time = 10692 ms.</strong> </pre>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Testing rxLinMod performance on a memory-optimized table with a primary key</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4SCS80-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">在带有主键的内存优化表上测试rxLinMod性能</h1>
                
            
            
                
<p class="calibre2">下面的步骤将测试<kbd class="calibre11">rxLinMod</kbd>在6096762位数据上的性能，这些数据存储在一个具有非聚集主键的内存优化表中。在步骤结束时，我们将记录CPU时间:</p>
<ol class="calibre14">
<li value="1" class="calibre8">为数据库中的内存优化表创建一个文件组:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">ALTER DATABASE PerfTuning  
   ADD FILEGROUP PerfTuningMOD CONTAINS MEMORY_OPTIMIZED_DATA; 
 
ALTER DATABASE PerfTuning  
   ADD FILE (NAME='PerfTuningMOD',  
   FILENAME = 'C:\Program Files\Microsoft SQL Server\MSSQL14.MSSQLSERVER\MSSQL\DATA\PerfTuningMOD.ndf')  
   TO FILEGROUP PerfTuningMOD; 
 
ALTER DATABASE PerfTuning  
   SET MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT=ON   
GO  </strong> </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">创建一个内存优化的表版本<kbd class="calibre11">dbo.AirFlights</kbd>:</li>
</ol>
<pre class="calibre18">    <strong class="calibre1">CREATE TABLE [dbo].[AirFlights_MOD] </strong>
    <strong class="calibre1">(  </strong>
    <strong class="calibre1">       [ID] INT IDENTITY(1,1) NOT NULL PRIMARY KEY NONCLUSTERED</strong>
    <strong class="calibre1">      ,[ArrDelay] SMALLINT</strong>
    <strong class="calibre1">      ,[CRSDepTime]     DECIMAL(6,4)</strong>
    <strong class="calibre1">      ,[DayOfWeek]      NVARCHAR(10) </strong>
    <strong class="calibre1">) WITH (MEMORY_OPTIMIZED=ON, DURABILITY = SCHEMA_AND_DATA);</strong>
    
    <strong class="calibre1">GO</strong>
    
    <strong class="calibre1">INSERT INTO [dbo].[AirFlights_MOD]</strong>
    <strong class="calibre1">(</strong>
    <strong class="calibre1">       [ArrDelay]       </strong>
    <strong class="calibre1">      ,[CRSDepTime]     </strong>
    <strong class="calibre1">      ,[DayOfWeek]      </strong>
    <strong class="calibre1">)</strong>
    <strong class="calibre1">SELECT </strong>
    <strong class="calibre1">       [ArrDelay]       </strong>
    <strong class="calibre1">      ,[CRSDepTime]     </strong>
    <strong class="calibre1">      ,[DayOfWeek]      </strong>
    <strong class="calibre1">FROM [dbo].[AirFlights] </strong>
    <strong class="calibre1">go</strong> </pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre8">执行以下程序:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">EXEC dbo.usp_TestPerformance '[dbo].[AirFlights_MOD]'</strong></pre>
<p class="calibre34">结果应该是这样的:</p>
<pre class="calibre33"><strong class="calibre1">SQL Server parse and compile time: </strong>
<strong class="calibre1">   CPU time = 2 ms, elapsed time = 2 ms.</strong>
<strong class="calibre1">STDOUT message(s) from external script:</strong> <br class="title-page-name"/><strong class="calibre1">Rows Read: 6096762, Total Rows Processed: 6096762, Total Chunk     <br class="title-page-name"/>Time: 0.072 seconds </strong>
<strong class="calibre1">Computation time: 0.077 seconds.</strong>
<strong class="calibre1">(8 rows affected)</strong>
<strong class="calibre1"> SQL Server Execution Times:</strong>
<strong class="calibre1">   CPU time = 2109 ms,  elapsed time = 8835 ms.</strong>
<strong class="calibre1"> SQL Server Execution Times: 2235 ms,  elapsed time = 10692 ms.</strong>
  </pre>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Testing rxLinMod performance on a memory-optimized table with a clustered ColumnStore index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4TBCQ0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">在具有聚集列存储索引的内存优化表上测试rxLinMod性能</h1>
                
            
            
                
<p class="calibre2">下面的步骤将测试<kbd class="calibre11">rxLinMod</kbd>在6096762位数据上的性能，这些数据存储在一个带有非聚集主键的内存优化表中。在步骤结束时，我们将记录CPU时间:</p>
<ol class="calibre14">
<li value="1" class="calibre8">使用<kbd class="calibre11">dbo.AirFlights</kbd>的聚集<kbd class="calibre11">columstore</kbd>索引版本创建一个内存优化表:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">CREATE TABLE [dbo].[AirFlights_MODCS]  
(   
    [ID] INT IDENTITY(1,1) NOT NULL PRIMARY KEY NONCLUSTERED 
   ,[ArrDelay] SMALLINT 
   ,[CRSDepTime] DECIMAL(6,4) 
   ,[DayOfWeek]      VARCHAR(10)  
) WITH (MEMORY_OPTIMIZED=ON, DURABILITY = SCHEMA_AND_DATA); 
GO 
 
INSERT INTO [dbo].[AirFlights_MODCS] 
( 
    [ArrDelay]        
   ,[CRSDepTime]      
   ,[DayOfWeek]       
) 
SELECT  
    [ArrDelay]        
   ,[CRSDepTime]      
   ,[DayOfWeek]       
FROM [dbo].[AirFlights]; 
GO 
ALTER TABLE [dbo].[AirFlights_MODCS] 
ADD INDEX CCI_Airflights_MODCS CLUSTERED COLUMNSTORE 
GO <br class="title-page-name"/></strong></pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre8">执行以下程序:</li>
</ol>
<pre class="calibre33"><strong class="calibre1">EXEC dbo.usp_TestPerformance '[dbo].[AirFlights_MODCS]'</strong> </pre>
<p class="calibre34">结果应该是这样的:</p>
<pre class="calibre33"><strong class="calibre1">SQL Server parse and compile time:  
   CPU time = 3 ms, elapsed time = 3 ms. 
STDOUT message(s) from external script:  
Rows Read: 6096762, Total Rows Processed: 6096762, Total Chunk Time: 0.088 seconds  
Computation time: 0.093 seconds. 
(8 rows affected) 
 SQL Server Execution Times: 
   CPU time = 1766 ms,  elapsed time = 8659 ms. 
 SQL Server Execution Times: 
   CPU time = 1782 ms,  elapsed time = 8662 ms.</strong> </pre>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Comparing results</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4U9TC0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">比较结果</h1>
                
            
            
                
<p class="calibre2">从下面的快速图表比较中可以看出，SQL Server R服务可以很好地利用优化的表:</p>
<div><img src="img/00188.jpeg" class="calibre98"/></div>
<p>图10.11与R服务结合使用时，经典主键、列存储、内存中以及内存+列存储的性能比较</p>
<p class="calibre2">有关性能比较的更多信息，您可以在此处访问<em class="calibre12">tomaka trun的</em>文章:</p>
<p class="calibre2"><a href="https://github.com/tomaztk/Performance-differences-between-RevoScaleR-ColumnStore-Table-and-In-Memory-OLTP-Table/blob/master/RevoScaleR_vs_ColumStore_vs_InMemoryOLTP.sql" class="calibre10">https://github . com/tomaztk/Performance-differences-between-revo scaler-column store-Table-and-In-Memory-OLTP-Table/blob/master/revo scaler _ vs _ column store _ vs _ inmemoryoltp . SQL</a></p>
<p class="calibre2"/>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Summary</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="4V8DU0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">摘要</h1>
                
            
            
                
<p class="calibre2">SQL Server 2016和SQL Server 2017包含了许多有用的功能，从JSON、PolyBase到高性能功能，如<kbd class="calibre11">ColumnStore</kbd>索引和内存优化表。这些功能中的大多数都是兼容的，可以增强您的高级分析体验。在本章中，您学习了在奥斯汀和特拉维斯县创建EMS事件预测和季节性趋势的步骤。我们在Azure Blob存储中使用了JSON数据源和CSV文件。最后，您还学习了如何利用<kbd class="calibre11">ColumnStore</kbd>和内存优化表来提高R服务的性能。</p>


            

            
        
    </body></html>
</body></html>