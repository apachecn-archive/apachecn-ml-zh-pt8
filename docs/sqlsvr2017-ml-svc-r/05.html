<html><head/><body>
<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>RevoScaleR Package</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2D7TI0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">RevoScaleR包</h1>
                
            
            
                
<p class="calibre2"><kbd class="calibre11">RevoScaleR</kbd>包自带微软机器学习R服务器和R服务。它也可用于R Client，但有一些限制，在<a target="_blank" href="part0025.html#NQU20-e3f81285367248f4bbc6431bcd4f926d" class="calibre10">第2章</a>、<em class="calibre12">微软机器学习服务器和SQL服务器概述</em>中讨论。鉴于快速发展和不断升级，本章将涵盖版本8。x和版本9。x-后者也可用于SQL Server 2017。版本9中的更改和升级。x是不容忽视的，也将包括在内。</p>
<p class="calibre2">本章包括以下主题:</p>
<ul class="calibre7">
<li class="calibre8">R的局限性受到质疑</li>
<li class="calibre8">可扩展的分布式计算环境</li>
<li class="calibre8">数据准备功能</li>
<li class="calibre8">描述性统计的函数</li>
<li class="calibre8">统计测试和抽样的函数</li>
<li class="calibre8">预测建模功能</li>
</ul>
<p class="calibre2">首先，这个R包是为在生态系统中处理而设计的，在生态系统中，客户端将连接到Microsoft R Server，以便在一个更强大的服务器上执行R代码，该服务器可能会保存整个数据集，而不仅仅是在客户端机器上工作的人将要处理的一小部分。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Overcomming R language limitations</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2E6E40-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">克服R语言限制</h1>
                
            
            
                
<p class="calibre2">在SQL Server 2016(和2017)之前，商业智能和数据科学家在<strong class="calibre1">SQL Server Analysis Services</strong>(<strong class="calibre1">SSAS</strong>)中拥有OLAP立方体、DMX语言和所有超级棒和酷的微软算法。但是，随着快速变化和更大的市场需求，集成开源产品(无论是R、Python、Perl还是任何其他产品)的需求实际上已经存在。下一个合乎逻辑的步骤是将它与一个。微软寻求解决方案，最终收购了Revolution Analytics，这让他们重新走上了正轨。Revolution R解决了关于R语言的主要问题。</p>
<p class="calibre2">微软解决了R的局限性。这些限制中有许多是针对r中更快的数据探索和并行编程技术。除此之外，MKL计算也得到了增强，从而使矩阵计算、标量计算以及产生笛卡尔积的计算变得更快。</p>
<p class="calibre2">以下限制得到了处理和解决:</p>
<ul class="calibre7">
<li class="calibre8">对于由大量相对较小的任务组成的细粒度并行来说，通信开销尤其成问题</li>
<li class="calibre8">负载平衡是指计算资源对问题的贡献不同</li>
<li class="calibre8">使用RAM和虚拟内存的影响，例如缓存未命中和页面错误</li>
<li class="calibre8">影响性能和通信开销的网络效应，如延迟和带宽</li>
<li class="calibre8">进程间冲突和线程调度</li>
<li class="calibre8">数据访问和其他I/O考虑事项</li>
</ul>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Scalable and distributive computational environments</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2F4UM0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">可扩展和分布式计算环境</h1>
                
            
            
                
<p class="calibre2"><kbd class="calibre11">RevoScaleR</kbd>包具有以下可用功能，本章将详细介绍这些功能。</p>
<p class="calibre2">要获得所有<kbd class="calibre11">ScaleR</kbd>函数的列表，可以使用下面的T-SQL:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'require(RevoScaleR)</strong>
<strong class="calibre1">                        OutputDataSet &lt;- data.frame(ls("package:RevoScaleR"))'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      (( Functions NVARCHAR(200)))</strong>  </pre>
<p class="calibre2">您可以在SSMS得到一个表，其中包含可以与<kbd class="calibre11">RevoScaleR</kbd>包一起使用的所有相关的<kbd class="calibre11">rx</kbd>功能。</p>
<p class="calibre2">基于这些功能的列表，可以准备更简单和更好的功能概述:</p>
<div><img src="img/00070.jpeg" class="calibre27"/></div>
<p>图RevoScaleR函数列表(来源:微软)</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Functions for data preparation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2G3F80-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">数据准备功能</h1>
                
            
            
                
<p class="calibre2">导入数据是数据准备过程中的第一步。导入数据是使用外部文件或通过建立与实时数据源的连接，将数据从任何外部系统导入系统的过程。在接下来的部分中，我们将研究如何导入存储为SPSS或SAS文件的数据，并使用ODBC连接字符串直接连接到外部实时数据库系统。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Data import from SAS, SPSS, and ODBC</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2H1VQ0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">从SAS、SPSS和ODBC导入数据</h1>
                
            
            
                
<p class="calibre2">将数据导入到R或SQL Server表中并不是<kbd class="calibre11">RevoScaleR</kbd>库的主要重点，但是既然这个在列表中，让我们简单地研究一下。通过这种方式，基于您的数据源，<kbd class="calibre11">RevoScaleR</kbd>包提供了许多连接不同数据源的能力。其中还有SAS和SPSS——两个非常广泛和常见的数据分析和预测分析统计程序。我们将只关注SAS软件(<a href="https://www.sas.com/" class="calibre10">https://www.sas.com/</a>)、SPSS Statistics(2009年被IBM收购)(<a href="https://www.ibm.com/products/spss-statistics" class="calibre10">https://www.ibm.com/products/spss-statistics</a>)或者SPSS Modeler(<a href="https://www.ibm.com/products/spss-modeler" target="_blank" class="calibre10">https://www.ibm.com/products/spss-modeler</a>)。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Importing SAS data</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2I0GC0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">导入SAS数据</h1>
                
            
            
                
<p class="calibre2">SAS是最流行的数据分析程序之一，如果不是最流行的统计分析、数据挖掘和机器学习程序的话。因此，让我们创建一个简单的SAS文件，并使用<kbd class="calibre11">ScaleR</kbd>函数读取它。</p>
<p class="calibre2">使用以下SAS代码(该代码随书提供)，您可以非常轻松地创建一个样本数据集:</p>
<div><img class="aligncenter45" src="img/00071.gif"/></div>
<p>图SAS代码的外观</p>
<p class="calibre2">现在，让我们假设我们的SAS数据存储在文件<kbd class="calibre11">sas_data.sas7bdat</kbd>中，如代码在<kbd class="calibre11">PROC DATA</kbd>语句中所示。</p>
<p class="calibre2">使用下面的R代码，我们可以将这个数据集提取并导入到R <kbd class="calibre11">data.frame</kbd>中:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                        SampleSASFile &lt;- file.path(rxGetOption("sampleDataDir"), "sas_data.sas7bdat")</strong>
<strong class="calibre1">                        #import into Dataframe</strong>
<strong class="calibre1">                        OutputDataSet &lt;- rxImport(SampleSASFile)</strong>
<strong class="calibre1">                        '</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       income  INT</strong>
<strong class="calibre1">      ,gender  INT</strong>
 <strong class="calibre1">     ,[count] INT</strong>
<strong class="calibre1">      ))</strong></pre>
<p class="calibre2">确保您的<kbd class="calibre11">sampleDataDir</kbd>持有数据样本。此外，您还可以指定其他路径，例如:</p>
<pre class="calibre19"><strong class="calibre1">SampleSASFile &lt;- file.path(("C:\\Users\\TomazK\\Documents\\CH05"), "sas_data.sas7bdat")</strong>  </pre>
<p class="calibre2">但是，您需要确保您已经授予了对该工作文件夹的访问权限。在这两种方法中，您都应该得到以表格形式显示的结果，从SAS文件中读取，如下所示:</p>
<div><img src="img/00072.gif" class="calibre50"/></div>
<p>图SAS代码结果的前景</p>
<p class="calibre2">导入SAS文件的另一种方式是直接使用<kbd class="calibre11">RxSasData</kbd>(在本例中，从R开始):</p>
<pre class="calibre19"><strong class="calibre1">SampleSASFile &lt;- file.path(("C:\\Users\\tomazK\\CH05"), "sas_data.sas7bdat")</strong>
<strong class="calibre1">sasDS &lt;- RxSasData(SampleSASFile, stringsAsFactors = TRUE, </strong>
<strong class="calibre1">                   colClasses = c(income = "integer", gender= "integer", count="integer"),</strong>
<strong class="calibre1">rowsPerRead = 1000)</strong>
<strong class="calibre1">rxHistogram( ~F(gender)|F(income), data = sasDS)</strong>  </pre>
<p class="calibre2">您可以很容易地从SAS数据文件生成直方图。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Importing SPSS data</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2IV0U0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">导入SPSS数据</h1>
                
            
            
                
<p class="calibre2">使用SPSS，过程是相似的。以下SPSS语法(该语法包含在本章中)生成存储在本地计算机上的示例数据集:</p>
<div><img class="aligncenter46" src="img/00073.gif"/></div>
<p>图SPSS语法的前景</p>
<p class="calibre2">这涉及到使用前面的SPSS语法生成的SPSS save文件将数据放入R服务，这与SAS文件基本相同:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                        SampleSPSSFile &lt;- file.path(rxGetOption("sampleDataDir"), "spss_data.sav")</strong>
<strong class="calibre1">                        #import into Dataframe</strong>
<strong class="calibre1">                        OutputDataSet &lt;- rxImport(SampleSPSSFile)</strong>
<strong class="calibre1">                        '</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       income  INT</strong>
<strong class="calibre1">      ,gender  INT</strong>
<strong class="calibre1">      ,[count] INT</strong>
<strong class="calibre1">      ))</strong>
  </pre>
<p class="calibre2">除此之外，<kbd class="calibre11">RevoScaleR</kbd>包还有一个特殊的功能，直接读取SPSS文件，名为<kbd class="calibre11">RxSpssData</kbd>。下面的R代码可以实现与前面的T-SQL代码相同的结果:</p>
<pre class="calibre19"><strong class="calibre1">SampleSPSSFile &lt;- file.path(("C:\\Users\\tomazK\\CH05"), "spss_data.sav")</strong>
<strong class="calibre1">spssDS &lt;- RxSpssData(SampleSPSSFile, stringsAsFactors = TRUE, </strong>
    <strong class="calibre1">                   colClasses = c(income = "integer", gender= "integer", count="integer"),rowsPerRead = 1000)</strong>
<strong class="calibre1">rxHistogram( ~F(income)|F(count), data = spssDS)</strong>
  </pre>
<p class="calibre2">并且<kbd class="calibre11">RevoScaleR</kbd>直方图可以直接与SPSS数据源一起使用，生成一个简单的直方图:</p>
<div><img src="img/00074.jpeg" class="calibre27"/></div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Importing data using ODBC</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2JTHG0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">使用ODBC导入数据</h1>
                
            
            
                
<p class="calibre2">使用ODBC驱动程序将可访问性扩展到几乎任何类型的数据库，您可以获得该数据库的驱动程序，并且该数据库具有通用的RDBM模型。</p>
<p class="calibre2"><kbd class="calibre11">RevoScaleR</kbd>包扩展了ODBS驱动程序列表，也支持Linux和其他系统。使用ODBC，您可以连接到MySQL、Oracle、PostgreSQL、Linux上的SQL Server、Cloudera和Teradata(在这种情况下，它比<kbd class="calibre11">RxTeradata</kbd>函数好用得多)。</p>
<p class="calibre2">以下示例将使用ODBC驱动程序从另一个SQL server实例获取数据，两者都使用了<kbd class="calibre11">RxOdbcData</kbd>和<kbd class="calibre11">RxSqlServerData</kbd>函数，因为它们是可互换的:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">            sConnectStr &lt;- "Driver={ODBC Driver 13 for SQL Server};Server=TOMAZK\MSSQLSERVER2017;Database=AdventureWorks;Trusted_Connection=Yes"</strong>
<strong class="calibre1">            sQuery = "SELECT TOP 10 BusinessEntityID,[Name],SalesPersonID FROM [Sales].[Store] ORDER BY BusinessEntityID ASC"</strong>
<strong class="calibre1">            sDS &lt;-RxOdbcData(sqlQuery=sQuery, connectionString=sConnectStr)</strong>
<strong class="calibre1">            OutputDataSet &lt;- data.frame(rxImport(sDS))</strong>
    <strong class="calibre1">                        '</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID  INT</strong>
<strong class="calibre1">      ,[Name]  NVARCHAR(50)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">这与在同一台服务器上运行以下内容是一样的:</p>
<pre class="calibre19"><strong class="calibre1">USE AdventureWorks;</strong>
<strong class="calibre1">GO</strong>
    
    
<strong class="calibre1">SELECT</strong>
<strong class="calibre1">TOP 10</strong>
<strong class="calibre1">BusinessEntityID</strong>
<strong class="calibre1">,[Name]</strong>
<strong class="calibre1">,SalesPersonID</strong>
<strong class="calibre1">FROM [Sales].[Store]</strong>
<strong class="calibre1">ORDER BY BusinessEntityID ASC</strong>
  </pre>
<p class="calibre2">在使用<kbd class="calibre11">RxOdbcData</kbd>函数的情况下，您应该检查凭证，并且您可能还想检查您正在使用哪个用户来运行脚本。您还可以创建一个新的登录和用户，并使用它来检查和执行脚本:<kbd class="calibre11">Adventureworks</kbd>数据库可以从微软的GitHub网站(<a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/adventure-works" target="_blank" class="calibre10">https://GitHub . com/Microsoft/SQL-server-samples/tree/master/samples/databases/adventure-works</a>)下载:</p>
<pre class="calibre19"><strong class="calibre1">EXECUTE AS USER='MSSQLSERVER01'</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">-- YOUR CODE</strong>
<strong class="calibre1">REVERT;</strong>
<strong class="calibre1">GO</strong>
  </pre>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Variable creation and data transformation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2KS220-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">变量创建和数据转换</h1>
                
            
            
                
<p class="calibre2">在定义数据管理和数据争论任务时，变量创建和数据转换是两个过程。这些任务对于正确的数据准备非常重要，并且可以更容易地为将来的任务分析数据。</p>
<p class="calibre2">我们将探讨的功能如下:</p>
<ul class="calibre7">
<li class="calibre8">变量创建和重新编码</li>
<li class="calibre8">数据转换</li>
<li class="calibre8">处理缺失值</li>
<li class="calibre8">排序、合并和分割数据集</li>
<li class="calibre8">按类别聚合(这意味着求和)，这类似于T-SQL聚合和Windows函数</li>
</ul>
<p class="calibre2">本部分将涵盖以下一些函数，主要关注数据转换、缺失值处理和数据集分割:</p>
<p class="calibre2"><kbd class="calibre11">RxDataSource</kbd>，<kbd class="calibre11">rxDataStep</kbd>，<kbd class="calibre11">rxDataStepXdf</kbd>，<kbd class="calibre11">RxFileSystem</kbd>，<kbd class="calibre11">rxFindFileInPath</kbd>，<kbd class="calibre11">rxFindPackage</kbd>，<kbd class="calibre11">rxFisherTest</kbd>，<kbd class="calibre11">RxForeachDoPar</kbd>，<kbd class="calibre11">rxGetInfo</kbd>，<kbd class="calibre11">rxGetInfoXdf</kbd>，<kbd class="calibre11">rxGetJobInfo</kbd>，<kbd class="calibre11">rxGetJobInfo</kbd>，<kbd class="calibre11">rxGetOption</kbd>，<kbd class="calibre11">rxGetVarInfo</kbd>，<kbd class="calibre11">rxGetVarNames</kbd>，<kbd class="calibre11">rxImport</kbd>，<kbd class="calibre11">rxImportToXdf</kbd>，<kbd class="calibre11">rxIsOpen</kbd>，<kbd class="calibre11">rxOdbcData</kbd>，<kbd class="calibre11">rxOptions</kbd>，<kbd class="calibre11">rxOpen</kbd>，<kbd class="calibre11">rxQuantile</kbd>，<kbd class="calibre11">rxReadXdf</kbd>，<kbd class="calibre11">rxResultsDF</kbd>，<kbd class="calibre11">rxSetFileSystem</kbd>，<kbd class="calibre11">rxSetInfo</kbd>，<kbd class="calibre11">rxSetInfoXdf</kbd>，<kbd class="calibre11">rxSetInfoXdf</kbd>，】</p>
<p class="calibre2">当使用数据库内R服务(或数据库内机器学习服务，也包括SQL Server 2017的Python)时，您应该记住在哪里以及如何进行任何类型的数据转换、数据争论以及排序和/或合并。在运行了许多性能和速度测试之后，很明显，在将数据集发送给<kbd class="calibre11">sp_execute_external_script</kbd>执行之前，许多管理和争论任务应该在数据库中完成。这组函数是唯一一组计算环境被认为非常重要的函数。用于统计测试、描述性统计和预测性统计的所有其他功能可以很容易地与外部过程一起使用，而不会影响性能或时间。</p>
<p class="calibre2">从<kbd class="calibre11">rxDataStep</kbd>函数开始，它为我们提供了许多提取和生成XDF文件的机会，使用数据库内的R:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet        </strong>
 <strong class="calibre1">                 df_sql4 &lt;- data.frame(df_sql)</strong>
<strong class="calibre1">                  outfile &lt;- file.path(rxGetOption("sampleDataDir"), "df_sql4.xdf") </strong>
<strong class="calibre1">                  rxDataStep(inData = df_sql4, outFile = outfile, overwrite = TRUE)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
  <strong class="calibre1">                ,[Name]</strong>
    <strong class="calibre1">              ,SalesPersonID</strong>
    <strong class="calibre1">              FROM [Sales].[Store]'</strong>
  </pre>
<p class="calibre2">这将在您的示例数据目录中生成<kbd class="calibre11">df_sql4.xdf</kbd>文件。如果您对该文件夹指向的位置感兴趣，您可以执行以下操作:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">         OutputDataSet &lt;- data.frame(path = file.path(rxGetOption("sampleDataDir")))'</strong>
  </pre>
<p class="calibre2">它将类似于下面的截图所示:</p>
<div><img class="aligncenter47" src="img/00075.gif"/></div>
<p class="calibre2">并确保您已经授予用户访问权限，执行<kbd class="calibre11">rxDataStep</kbd>代码，因为代码将在目标位置创建一个物理XDF文件。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Variable creation and recoding</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2LQIK0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">变量创建和重新编码</h1>
                
            
            
                
<p class="calibre2">使用<kbd class="calibre11">rxGetVarInfo</kbd>会将关于<kbd class="calibre11">data.frame</kbd>的信息暴露给<kbd class="calibre11">sp_execute_external_script</kbd>输出。很明显，这些函数中的一些从来不是为向<kbd class="calibre11">data.frame</kbd>呈现输出而设计的，而只是为探索数据集而设计的。其中一些函数——例如<kbd class="calibre11">rxGetVarInfo</kbd>——在R环境中会给出很好的输出，但是在SQL Server数据库中输出的数据帧中很难操作:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet        </strong>
  <strong class="calibre1">                var_info &lt;- rxGetVarInfo(df_sql)</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(unlist(var_info))'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
  </pre>
<p class="calibre2">请注意，我们使用的是<kbd class="calibre11">unlist</kbd>函数，它在一个向量中取消了列表集。为了比较输出，我们可以在R环境中运行相同的脚本:</p>
<pre class="calibre19">library(RevoScaleR) 
sConnectStr &lt;- "Driver={ODBC Driver 13 for SQLServer};Server=TOMAZK\\MSSQLSERVER2017;Database=AdventureWorks;Trusted_Connection=Yes" 
sQuery = "SELECT  BusinessEntityID,[Name],SalesPersonID FROM [Sales].[Store] ORDER BY BusinessEntityID ASC" 
sDS &lt;-RxOdbcData(sqlQuery=sQuery, connectionString=sConnectStr) 
df_sql &lt;- data.frame(rxImport(sDS)) </pre>
<p class="calibre2">现在，运行<kbd class="calibre11">rxGetVarInfo(df_sql)</kbd>将会给您一个稍微不同的导出:</p>
<pre class="calibre19">&gt; var_info &lt;- rxGetVarInfo(df_sql) 
&gt; var_info 
Var 1: BusinessEntityID, Type: integer, Low/High: (292, 2051) 
Var 2: Name, Type: character 
Var 3: SalesPersonID, Type: integer, Low/High: (275, 290) </pre>
<p class="calibre2">在与<kbd class="calibre11">unlist()</kbd>函数分离后，我们得到相同的信息，以稍微不同的方式书写:</p>
<pre class="calibre19">&gt; df &lt;- data.frame(unlist(var_info)) 
&gt; df 
                         unlist.var_info. 
BusinessEntityID.varType          integer 
BusinessEntityID.storage            int32 
BusinessEntityID.low                  292 
BusinessEntityID.high                2051 
Name.varType                    character 
Name.storage                       string 
SalesPersonID.varType             integer 
SalesPersonID.storage               int32 
SalesPersonID.low                     275 
SalesPersonID.high                    290 </pre>
<p class="calibre2">这表明，与T-SQL数据工程师相比，有些变量创建和重新编码的函数对R数据工程师更有意义。</p>
<p class="calibre2"><kbd class="calibre11">rxGetInfo()</kbd>函数将获得数据集的大小和观察值/变量的数量:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
 <strong class="calibre1">                 library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet        </strong>
  <strong class="calibre1">                var_info &lt;- rxGetInfo(df_sql)</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(unlist(var_info))'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
    <strong class="calibre1">               BusinessEntityID</strong>
   <strong class="calibre1">               ,[Name]</strong>
  <strong class="calibre1">                ,SalesPersonID</strong>
  <strong class="calibre1">                FROM [Sales].[Store]'</strong>
  </pre>
<p class="calibre2">同样的逻辑也适用:如果您运行这个R环境，您将获得更整洁的信息显示:</p>
<pre class="calibre19">&gt; rxGetInfo(df_sql) 
Data frame: df_sql  
Number of observations: 701  
Number of variables: 3  </pre>
<p class="calibre2">向该函数添加一些附加参数也会产生更丰富的输出，如下所示:</p>
<pre class="calibre19">&gt; rxGetInfo(df_sql, getVarInfo = TRUE) 
Data frame: df_sql  
Number of observations: 701  
Number of variables: 3  
Variable information:  
Var 1: BusinessEntityID, Type: integer, Low/High: (292, 2051) 
Var 2: Name, Type: character 
Var 3: SalesPersonID, Type: integer, Low/High: (275, 290) </pre>
<p class="calibre2">用<kbd class="calibre11">rxGetVarInfo</kbd>，<kbd class="calibre11">rxGetInfo</kbd>将创建一个元素列表。<kbd class="calibre11">rxGetVarInfo</kbd>将生成一个列表列表，其中元组的数量等于变量的数量，<kbd class="calibre11">rxGetInfo</kbd>将生成一个包含六个元素的列表，其中每个列表将保存关于对象的信息:</p>
<div><img class="aligncenter48" src="img/00076.gif"/></div>
<p class="calibre2">了解这一点后，可以稍微修改前面的T-SQL执行，以便通过向结果集显示元素(元组)以更易读的格式显示相关信息:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet        </strong>
<strong class="calibre1">            get_Info &lt;- rxGetInfo(df_sql)             </strong>
<strong class="calibre1">            Object_names &lt;- c("Object Name", "Number of Rows", "Number of Variables")</strong>
<strong class="calibre1">            Object_values &lt;- c(get_Info$objName, get_Info$numRows, get_Info$numVars)</strong>
<strong class="calibre1">            OutputDataSet &lt;- data.frame(Object_names, Object_values)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
 <strong class="calibre1">                  BusinessEntityID</strong>
 <strong class="calibre1">                 ,[Name]</strong>
   <strong class="calibre1">               ,SalesPersonID</strong>
   <strong class="calibre1">               FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       ObjectName NVARCHAR(100)</strong>
<strong class="calibre1">      ,ObjectValue NVARCHAR(MAX)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">SQL Server Management Studio中返回的结果:</p>
<div><img class="aligncenter49" src="img/00077.gif"/></div>
<p class="calibre2">这看起来非常整洁，花费一些额外的努力肯定会得到更好的格式化结果，更容易阅读，也更有信息量。</p>
<p class="calibre2">在本例中，您还看到了如何创建一个新变量。这在清理数据或记录/存储数据时尤其方便。</p>
<p class="calibre2">假设您想要重新编码数据集中现有变量的值，并创建一个新变量。可以使用标准R代码来实现，如下所示:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            #first create an empty variable</strong>
<strong class="calibre1">            df_sql$BusinessType &lt;- NA</strong>
<strong class="calibre1">            df_sql$BusinessType[df_sql$BusinessEntityID&lt;=1000] &lt;- "Car Business"</strong>
<strong class="calibre1">            df_sql$BusinessType[df_sql$BusinessEntityID&gt;1000] &lt;- "Food Business"</strong>
<strong class="calibre1">            OutputDataSet &lt;- df_sql'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID INT</strong>
<strong class="calibre1">      ,[Name] NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ,TypeOfBusiness NVARCHAR(MAX)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">或者，您可以使用<kbd class="calibre11">rxDataStep()</kbd>函数和<kbd class="calibre11">transformFunc</kbd>参数，通过转换旧值创建一个新变量:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">                  df_sql$BusinessEntityID_2 &lt;- NA</strong>

<strong class="calibre1">            myXformFunc &lt;- function(dataList) {</strong>
<strong class="calibre1">             #dataList$BussEnt &lt;- 100 * dataList$BusinessEntityID</strong>
<strong class="calibre1">            if (dataList$BusinessEntityID&lt;=1000){dataList$BussEnt &lt;- "Car Business"} else {dataList$BussEnt &lt;- "Food Business"}</strong>
<strong class="calibre1">                  return (dataList)</strong>
<strong class="calibre1">                  }</strong>
 
<strong class="calibre1">                  df_sql &lt;- rxDataStep(inData = df_sql, transformFunc = myXformFunc)</strong>
<strong class="calibre1">                  OutputDataSet &lt;- df_sql'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID INT</strong>
<strong class="calibre1">      ,[Name] NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ,TypeOfBusiness NVARCHAR(MAX)</strong>
<strong class="calibre1">      ));</strong></pre>
<p class="calibre2"><kbd class="calibre11">rxDataStep()X</kbd>是一个非常强大的功能，主要用于数据选择、子集设置、数据转换以及为所需数据集创建新变量。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Dataset subsetting</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2MP360-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">数据集子集化</h1>
                
            
            
                
<p class="calibre2">使用<kbd class="calibre11">rxDataStep()</kbd>函数设置数据子集也相对简单:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">                  df_sql_subset &lt;- rxDataStep(inData = df_sql, varsToKeep = NULL, rowSelection = (BusinessEntityID&lt;=1000))</strong>
<strong class="calibre1">                  OutputDataSet &lt;- df_sql_subset'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID INT</strong>
<strong class="calibre1">      ,[Name] NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">请记住，使用R代码的子集化操作可能会带来不必要的内存和I/O开销，尤其是在将整个数据集抽取到R中，而不是预先对数据进行子集化时。在前面的例子中，使用<kbd class="calibre11">rxDataStep</kbd>中的<kbd class="calibre11">rowSelection</kbd>参数可以很容易地替换为<kbd class="calibre11">@input_data_1</kbd>参数中的<kbd class="calibre11">WHERE</kbd>子句。所以请记住这一点，并始终避免不必要的交通。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Dataset merging</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2NNJO0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">数据集合并</h1>
                
            
            
                
<p class="calibre2"><kbd class="calibre11">rxMerge()</kbd>函数将两个数据集合并成一个。数据集必须是数据帧(或XDF格式)，并且操作类似于T-SQL中的<kbd class="calibre11">JOIN</kbd>子句(不要将<kbd class="calibre11">rxMerge()</kbd>函数与T-SQL的<kbd class="calibre11">MERGE</kbd>语句混淆)。使用<kbd class="calibre11">matchVars</kbd>参数基于一个或多个变量合并两个数据集。此外，当使用本地计算上下文(我们将在下一个示例中使用)时，也需要定义数据的排序，因为R中的<kbd class="calibre11">data.frames</kbd>——作为向量的集合——没有预先排序或者没有任何排序。因此，如果没有进行预排序，则必须将<kbd class="calibre11">autoSort</kbd>参数设置为true ( <kbd class="calibre11">autosort = TRUE</kbd>):</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">      library(RevoScaleR)</strong>
<strong class="calibre1">      df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">      someExtraData &lt;- data.frame(BusinessEntityID = 1:1200, department = rep(c("a", "b", "c", "d"), 25), Eff_score = rnorm(100))</strong>
<strong class="calibre1">      df_sql_merged &lt;- rxMerge(inData1 = df_sql, inData2 = someExtraData, overwrite = TRUE, matchVars = "BusinessEntityID", type = "left" ,autoSort = TRUE)</strong>
<strong class="calibre1">      OutputDataSet &lt;- df_sql_merged'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID INT</strong>
<strong class="calibre1">      ,[Name] NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ,Department CHAR(1)</strong>
<strong class="calibre1">      ,Department_score FLOAT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">这段T-SQL代码在两个数据集上创建了一个左连接。Dataframe 2(称为<kbd class="calibre11">someExtraData</kbd>)是动态创建的，但它可以是从XDF文件或任何手动插入的数据集中读取的任何其他数据帧，并将在R运行时连接。此外，请注意哪个是第一个数据框，哪个是第二个数据框，以及您使用的连接类型。前面的示例指定了以下内容:</p>
<pre class="calibre19">inData1 = df_sql, inData2 = someExtraData, type = "left" </pre>
<p class="calibre2">然而，数据帧的顺序可以改变如下:</p>
<pre class="calibre19">inData1 = someExtraData , inData2 = df_sql, type = "left" </pre>
<p class="calibre2">然后，输出将以不同的方式呈现(数据框中列的排序将会改变)。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Functions for descriptive statistics</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2OM4A0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">描述性统计的函数</h1>
                
            
            
                
<p class="calibre2">描述性统计为理解数据提供了见解。这些是通过汇总特征和度量来描述给定数据集的汇总统计数据，例如集中趋势和分布度量(或可变性)。集中趋势包括平均值、中值、众数的计算，而可变性的测量包括范围、四分位数、最小和最大值、方差和标准偏差，以及偏斜度和峰度。</p>
<p class="calibre2">这些统计数据由<kbd class="calibre11">RevoScaleR</kbd>包中的<kbd class="calibre11">rx-</kbd>函数覆盖，这意味着您可以通过调用:<kbd class="calibre11">rxSummary</kbd>、<kbd class="calibre11">rxCrossTabs</kbd>、<kbd class="calibre11">rxMarginals</kbd>、<kbd class="calibre11">rxQuantile</kbd>、<kbd class="calibre11">rxCube</kbd>和<kbd class="calibre11">rxHistogram</kbd>来使用该包的所有计算优势，而不用担心性能、内存不足异常或哪个R包持有正确的函数。</p>
<p class="calibre2">我们将使用<kbd class="calibre11">AdventureWorks</kbd>数据库中的<kbd class="calibre11">[Sales].[vPersonDemographics]</kbd>视图来简洁地展示这些功能的可用性:</p>
<pre class="calibre18"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            summary &lt;- rxSummary(~ TotalChildren,  df_sql, summaryStats = c( "Mean", "StdDev", "Min", "Max","Sum","ValidObs", "MissingObs"))</strong>
<strong class="calibre1">            OutputDataSet &lt;- summary$sDataFrame'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">        VariableName NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,"Mean"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"StdDev"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"Min"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"Max"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"Sum"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"ValidObs"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"MissingObs"NVARCHAR(100)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">通过一行R代码，您可以获得一些汇总统计数据。我更喜欢使用<kbd class="calibre11">summaryStats</kbd>参数来列出统计数据，但是请注意，统计数据的顺序并不意味着输出的顺序相同。此外，使用元素<kbd class="calibre11">summary$sDataFrame</kbd> dataframe作为<kbd class="calibre11">rxSummary</kbd>的结果将自动生成包含所有数值变量汇总的数据框。</p>
<p class="calibre2">T-SQL查询的结果如下:</p>
<div><img class="aligncenter50" src="img/00078.gif"/></div>
<p class="calibre2"><kbd class="calibre11">rxSummary()</kbd>函数也包含一个公式，通过该公式，您可以指定在计算描述性统计数据时该函数将考虑哪些变量。在我们的例子中，我们只使用了<kbd class="calibre11">TotalChildren</kbd>变量:</p>
<pre class="calibre19">rxSummary(~ TotalChildren, ... </pre>
<p class="calibre2">但是让我们假设，我们想要得到所有变量的描述符；我们简单地写下以下内容:</p>
<pre class="calibre19">rxSummary(~.,  .... </pre>
<p class="calibre2">这将为我们提供所有变量的统计数据，如下图所示:</p>
<div><img class="aligncenter51" src="img/00079.gif"/></div>
<p class="calibre2">注意，只考虑整数(连续)类型的变量，而诸如<kbd class="calibre11">MaritalStatus</kbd>、<kbd class="calibre11">Education</kbd>和<kbd class="calibre11">Occupation</kbd>的变量将表示为<kbd class="calibre11">NULL</kbd>，因为这些变量在r中被视为分类变量</p>
<p class="calibre2">为此，首先，我们需要指定因子变量，基于此，我们将能够运行统计数据:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">      library(RevoScaleR)</strong>
<strong class="calibre1">      df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">      df_sql_r &lt;- rxFactors(inData = df_sql, sortLevels = TRUE,</strong>
<strong class="calibre1">factorInfo = list(MS = list(levels = c("M","S"), otherLevel=NULL, varName="MaritalStatus")))</strong>
<strong class="calibre1">                  summary &lt;- rxSummary(~ MS,  df_sql_r)</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(summary$categorical)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">        MS NVARCHAR(MAX)</strong>
<strong class="calibre1">        ,"Counts"INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">该函数将给出<kbd class="calibre11">MaritalStatus</kbd>因子的简单计数:</p>
<pre class="calibre19"><strong class="calibre1">MS Counts 
M  10011 
S   8473</strong> </pre>
<p class="calibre2">同样的逻辑可以应用于所有其他分类变量。<kbd class="calibre11">rxSummary()</kbd>函数中的公式也让用户能够组合不同的变量。例如，不使用下面的代码:</p>
<pre class="calibre19">rxSummary(~ TotalChildren, df_sql_r) </pre>
<p class="calibre2">我们也可以使用下面的代码:</p>
<pre class="calibre19">rxSummary(NumberCarsOwned ~ TotalChildren, df_sql_r) </pre>
<p class="calibre2">这将同时计算两个变量的观察统计数据:</p>
<pre class="calibre19"><strong class="calibre1">Name                          Mean     StdDev   Min Max Sum   ValidObs MissObs 
NumberCarsOwned:TotalChildren 3.258656 4.473517 0   20  60233 18484    0      </strong>    </pre>
<p class="calibre2">这也可以针对分类变量进行计算。首先需要将这些变量重新编码为因子，然后可以计算相同的汇总统计数据:</p>
<pre class="calibre19">rxSummary(~ TotalChildren:F(MS), df_sql_r) </pre>
<p class="calibre2">使用<kbd class="calibre11">sp_execute_external_script</kbd>的完整R和T-SQL代码如下:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            df_sql_r &lt;- rxFactors(inData = df_sql, sortLevels = TRUE,factorInfo = list(MS = list(levels = c("M","S"), otherLevel=NULL, varName="MaritalStatus")))</strong>
<strong class="calibre1">      summary &lt;- rxSummary(~F(MS):TotalChildren, df_sql_r, summaryStats = c( "Mean", "StdDev", "Min", "Max", "ValidObs", "MissingObs", "Sum"), categorical=c("MS"))</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(summary$categorical)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">        Category NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,"MS"NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,"Means"FLOAT</strong>
<strong class="calibre1">      ,"StDev"FLOAT</strong>
<strong class="calibre1">      ,"Min"INT</strong>
<strong class="calibre1">      ,"Max"INT</strong>
<strong class="calibre1">      ,"Sum"INT</strong>
<strong class="calibre1">      ,"ValidObs"INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">以下是每个因素级别的结果:</p>
<pre class="calibre19"><strong class="calibre1">Name               Mean     StdDev   Min Max Sum   ValidObs MissingObs</strong>
<strong class="calibre1"> TotalChildren:F_MS 1.844352 1.612408 0   5   34091 18484    0         </strong>
    
<strong class="calibre1">Statistics by category (2 categories):</strong>
    
<strong class="calibre1">Category                  F_MS Means    StdDev   Min Max Sum   ValidObs</strong>
<strong class="calibre1">TotalChildren for F(MS)=M M    2.080412 1.583326 0   5   20827 10011   </strong>
<strong class="calibre1">TotalChildren for F(MS)=S S    1.565443 1.601977 0   5   13264  8473   </strong>
  </pre>
<p class="calibre2">分位数和十分位数对于查看数据分布也非常有用，并且<kbd class="calibre11">RevoScaleR</kbd>包提供了<kbd class="calibre11">rxQuantile</kbd>功能。使用T-SQL，可以按如下方式返回结果集:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
   <strong class="calibre1">               df_sql &lt;- InputDataSet</strong>
  <strong class="calibre1">                quan &lt;- rxQuantile(data = df_sql, varName = "TotalChildren")</strong>
  <strong class="calibre1">                quan &lt;- data.frame(quan)</strong>
<strong class="calibre1">                  values &lt;- c("0%","25%","50%","75%","100%")</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(values,quan)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
 <strong class="calibre1">WITH RESULT SETS</strong>
    <strong class="calibre1">  ((</strong>
 <strong class="calibre1">           Quartile NVARCHAR(100)</strong>
   <strong class="calibre1">         ,QValue FLOAT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">这给了我们以下结果:</p>
<pre class="calibre19"><strong class="calibre1">0%  25%  50%  75% 100% </strong>
<strong class="calibre1">0    0    2    3    5 </strong>
  </pre>
<p class="calibre2">我们还可以通过对<kbd class="calibre11">rxQuantile()</kbd>函数稍加修改来修改和计算十分位数:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            dec &lt;- rxQuantile(data = df_sql, varName = "TotalChildren",  probs = seq(from = 0, to = 1, by = .1))</strong>
<strong class="calibre1">            dec &lt;- data.frame(dec)</strong>
<strong class="calibre1">      values &lt;- c("0%","10%","20%","30%","40%","50%","60%","70%","80%","90%","100%")</strong>
<strong class="calibre1">            OutputDataSet &lt;- data.frame(values,dec)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">             Decile NVARCHAR(100)</strong>
<strong class="calibre1">            ,DValue FLOAT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">计算交叉表——两个(或更多)变量之间的关系——我们将使用两个函数:<kbd class="calibre11">rxCrossTabs</kbd>和<kbd class="calibre11">rxMargins</kbd>。交叉表通常以列联表或任何其他<em class="calibre12"> [n]*[m] </em>表格式表示；这实际上取决于每个变量的级数。</p>
<p class="calibre2">我们将使用我们的两个变量<kbd class="calibre11">NumberCarsOwned</kbd>和<kbd class="calibre11">TotalChildren</kbd>来探索<kbd class="calibre11">rxCrossTabs</kbd>:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
 <strong class="calibre1">     ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet</strong>
  <strong class="calibre1">                crosstab &lt;- rxCrossTabs(N(NumberCarsOwned) ~ F(TotalChildren),  df_sql, means=FALSE) #means=TRUE</strong>
<strong class="calibre1">                  children &lt;- c(0,1,2,3,4,5)</strong>
    <strong class="calibre1">              OutputDataSet &lt;- data.frame(crosstab$sums, children)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
  <strong class="calibre1">    ((</strong>
 <strong class="calibre1">            NumberOfCarsOwnedSUM INT</strong>
   <strong class="calibre1">         ,NumberOfChildren INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">使用<kbd class="calibre11">rxCrossTabs</kbd>计算交叉表可以得到两种类型的统计数据:观察值的计数和观察值的平均值，给定intersect的类别。这是使用手段<kbd class="calibre11">= TRUE</kbd>或手段<kbd class="calibre11">= FALSE</kbd>参数操纵的。该函数的操作方式需要因变量和自变量，在我们的示例中，可以从结果中检索信息，如下所示:</p>
<pre class="calibre19"><strong class="calibre1">Cross Tabulation Results for: N(NumberCarsOwned) ~ F(TotalChildren)</strong>
<strong class="calibre1">Data: df_sql</strong>
<strong class="calibre1">Dependent variable(s): N(NumberCarsOwned)</strong>
<strong class="calibre1">Number of valid observations: 18484</strong>
<strong class="calibre1">Number of missing observations: 0 </strong>
<strong class="calibre1">Statistic: sums </strong>
  </pre>
<p class="calibre2">为了成功地计算交叉表，自变量必须以因子的形式出现。在这种情况下，<kbd class="calibre11">TotalChildren</kbd>变量包装了一个<kbd class="calibre11">F()</kbd>函数，表示运行时的因子转换。</p>
<p class="calibre2">这可以使用基础包中的标准条形图或R:</p>
<div><img src="img/00080.jpeg" class="calibre51"/></div>
<p class="calibre2">使用以下代码通过<kbd class="calibre11">barplot</kbd>功能绘制直方图:</p>
<pre class="calibre19">library(RColorBrewer) 
barplot(OutputDataSet$V1, xlab = "Number of children",ylab = "Number of cars owned", 
        legend.text = c("0 Child","1 Child","2 Child","3 Child","4 Child","5 Child"), col=brewer.pal(6, "Paired")) </pre>
<p class="calibre2">使用分类变量，不需要显式转换:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
 <strong class="calibre1">     @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
 <strong class="calibre1">           library(RevoScaleR)</strong>
  <strong class="calibre1">          df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            crosstab &lt;- rxCrossTabs(NumberCarsOwned ~ MaritalStatus,  df_sql, means=FALSE) </strong>
 <strong class="calibre1">           status &lt;- c("M","S")</strong>
  <strong class="calibre1">          OutputDataSet &lt;- data.frame(crosstab$sums, status)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
   <strong class="calibre1">   ((</strong>
  <strong class="calibre1">           NumberOfCarsOwnedSUM INT</strong>
   <strong class="calibre1">          ,MaritalStatus NVARCHAR(100)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">此外，transform参数可用于重新编码、重新计算或以某种方式转换任何变量。来自<kbd class="calibre11">rxCrossTabs</kbd>的列联表的边际统计数据可以使用<kbd class="calibre11">rxMarginals</kbd>函数调用，该函数简单地包装在<kbd class="calibre11">rxCrossTabs</kbd>周围。</p>
<p class="calibre2">边际统计将为您提供所需变量的每行或每列的总和、计数或平均值:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
  <strong class="calibre1">                library(RevoScaleR)</strong>
    <strong class="calibre1">              df_sql &lt;- InputDataSet</strong>
    <strong class="calibre1">              mar &lt;- rxMarginals(rxCrossTabs(NumberCarsOwned ~ F(TotalChildren), data=df_sql, margin=TRUE, mean=FALSE))</strong>
<strong class="calibre1">                  OutputDataSet  &lt;- data.frame(mar$NumberCarsOwned$grand)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
 <strong class="calibre1">     SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
  <strong class="calibre1">          GrandTotal INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">结果如下:</p>
<pre class="calibre19"><strong class="calibre1">&gt; mar$NumberCarsOwned$grand 
[1] 27776</strong> </pre>
<p class="calibre2">探索数据也可以使用图表来完成，并且<kbd class="calibre11">RevoScaleR</kbd>包带有一个线形和条形图，两者都是为处理大型数据集而设计的。</p>
<p class="calibre2">以下是其中一个变量的简单预览:</p>
<div><img src="img/00081.jpeg" class="calibre52"/></div>
<p class="calibre2">使用下面一行R代码:</p>
<pre class="calibre19">rxHistogram(~NumberCarsOwned, data=df_sql) </pre>
<p class="calibre2">这已经转换为婚姻状况因素，如下所示:</p>
<pre class="calibre19">rxHistogram(~F(MS), data=df_sql_r) </pre>
<div><img class="aligncenter52" src="img/00082.jpeg"/></div>
<p class="calibre2">此外，变量可以组合如下(婚姻状况与拥有的汽车数量):</p>
<pre class="calibre19">rxHistogram(~ NumberCarsOwned | F(MS), title="Cars owned per Marital Status",  numBreaks=10, data = df_sql_r) 
 </pre>
<p class="calibre2">并且我们得到下面的情节，显示婚姻状况(<strong class="calibre1">M</strong>——已婚；<strong class="calibre1"> S </strong> - single)和作为分类变量的汽车拥有总数(<strong class="calibre1"> 0 </strong> -没有汽车，<strong class="calibre1"> 1 </strong> -拥有1辆汽车，<strong class="calibre1"> 2 </strong> -拥有两辆汽车，<strong class="calibre1"> 3 </strong> -拥有3辆汽车，<strong class="calibre1"> 4 </strong> -拥有4辆汽车):</p>
<div><img src="img/00083.jpeg" class="calibre53"/></div>
<p class="calibre2">除了柱状图，我们还可以使用线图，但这次使用不同的变量:</p>
<pre class="calibre19">rxLinePlot(as.numeric(log(TotalPurchaseYTD)) ~ as.factor(DateFirstPurchase), data = df_sql_r, rowSelection=  
             DateFirstPurchase &gt;= "2001-07-01 00:00:00.000"&amp;amp; DateFirstPurchase &lt;= "2001-07-17 00:00:00.000", type="p") </pre>
<p class="calibre2">对于半年多一点的时间周期(2001年1月1日至7月17日之间)，该图显示了该时间周期内采购总额的对数变量。在这种情况下，我们需要分解日期变量，我们还使用了<kbd class="calibre11">log()</kbd>函数来平衡购买量。我们没有使用<kbd class="calibre11">rxHistogram</kbd>，而是使用另一个<kbd class="calibre11">RevoScaleR</kbd>函数<kbd class="calibre11">rxLinePlot</kbd>，来绘制大型数据集的图表。<kbd class="calibre11">rxLinePlot</kbd>代表一个折线图:</p>
<div><img src="img/00084.jpeg" class="calibre54"/></div>
<p class="calibre2">因此，最后，我们可以使用<kbd class="calibre11">par()</kbd>函数组合所有三个图形，安排两列，每列有一个或两个图形:</p>
<pre class="calibre19"># combined 
h1 &lt;- rxHistogram(~NumberCarsOwned, data=df_sql) 
h2 &lt;- rxHistogram(~F(MS), data=df_sql_r) 
p1 &lt;- rxLinePlot(as.numeric(log(TotalPurchaseYTD)) ~ as.factor(DateFirstPurchase), data = df_sql_r, rowSelection=  
             DateFirstPurchase &gt;= "2001-07-01 00:00:00.000"&amp;amp; DateFirstPurchase &lt;= "2001-07-17 00:00:00.000", type="p") 
 
print(h1, position = c(0, 0.5, 0.5, 1), more = TRUE) 
print(h2, position = c(0.5, 0.5, 1, 1), more = TRUE) 
print(p1, position = c(0.5, 0.05, 1, 0.5)) </pre>
<p class="calibre2">当结合最具信息性的变量时，使用图表有利于讲故事、客户旅程或简单地快速理解数据。另一个好方法是使用markdown文档，并在一个块中包含多个图形。将<kbd class="calibre11">par()</kbd>功能与<kbd class="calibre11">rxHistogram</kbd>或<kbd class="calibre11">rxLinePlot</kbd>结合使用的另一个好处是，它可能不总是按预期显示图形。这是由于<kbd class="calibre11">par()</kbd>功能的一些兼容性问题。或者，使用<kbd class="calibre11">print()</kbd>功能并定位每个图形是另一种方式，不会遇到可能的问题:</p>
<div><img src="img/00085.jpeg" class="calibre55"/></div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Functions for statistical tests and sampling</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2PKKS0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">统计测试和抽样的函数</h1>
                
            
            
                
<p class="calibre2">统计检验对于确定两个(或多个)变量之间的相关性以及它们的相关方向(正、中性或负)非常重要。从统计学上讲，相关性是对两个变量之间的关联强度及其方向的度量。<kbd class="calibre11">RevoScaleR</kbd>包支持卡方、Fischer和Kendall等级相关性的计算。基于变量的类型，你可以区分肯德尔、斯皮尔曼或皮尔逊相关系数。</p>
<p class="calibre2">对于卡方检验，我们将使用<kbd class="calibre11">rxChiSquareTest()</kbd>函数，该函数使用列联表来查看两个变量是否相关。一个小的卡方检验统计量意味着观察到的数据与您的预期数据非常吻合，分别表示存在相关性。卡方的计算公式如下:</p>
<div><img src="img/00086.jpeg" class="calibre56"/></div>
<p class="calibre2">在计算这个统计独立性测试之前，我们必须有<kbd class="calibre11">xCrossTab</kbd>或xCube格式的数据。因此，T-SQL查询需要首先生成交叉表，以便计算卡方系数。</p>
<p class="calibre2">卡方是根据两个分类变量生成的，如下所示:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            df_sql_r &lt;- rxFactors(inData = df_sql, sortLevels = TRUE,factorInfo = list(MS = list(levels = c("M","S"), otherLevel=NULL, varName="MaritalStatus")))</strong>
<strong class="calibre1">            df_sql_r$Occupation &lt;- as.factor(df_sql_r$Occupation)</strong>
<strong class="calibre1">            df_sql_r$MS &lt;- df_sql_r$MS</strong>
<strong class="calibre1">            testData &lt;- data.frame(Occupation = df_sql_r$Occupation, Status=df_sql_r$MS)</strong>
<strong class="calibre1">            d &lt;- rxCrossTabs(~Occupation:Status,  testData, returnXtabs = TRUE)</strong>
<strong class="calibre1">            chi_q &lt;- rxChiSquaredTest(d)</strong>
    
<strong class="calibre1">            #results</strong>
<strong class="calibre1">            xs &lt;- chi_q$''X-squared''</strong>
<strong class="calibre1">            p &lt;- chi_q$''p-value''</strong>
<strong class="calibre1">            OutputDataSet &lt;- data.frame(xs,p)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">             Chi_square_value NVARCHAR(100)</strong>
<strong class="calibre1">            ,Stat_significance NVARCHAR(100)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">将返回以下结果:</p>
<pre class="calibre19"><strong class="calibre1">Chi-squared test of independence between Occupation and Status </strong>
<strong class="calibre1"> X-squared df p-value</strong>
<strong class="calibre1"> 588.2861  4  5.312913e-126</strong>
  </pre>
<p class="calibre2">使用Kendall Tau，您可以使用R代码计算等级和先前相关结果之间的相关性:</p>
<pre class="calibre19"><strong class="calibre1">rxKendallCor(d, type = "b")</strong>
  </pre>
<p class="calibre2">以下是结果:</p>
<pre class="calibre19"><strong class="calibre1">  estimate 1 p-value</strong>
<strong class="calibre1"> -0.05179647       0</strong>
<strong class="calibre1">   HA: two.sided </strong>
  </pre>
<p class="calibre2">同样的原则也可以用在T-SQL查询中:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
    <strong class="calibre1">      @language = N'R'</strong>
    <strong class="calibre1">      ,@script = N'</strong>
    <strong class="calibre1">            library(RevoScaleR)</strong>
    <strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
    <strong class="calibre1">            df_sql_r &lt;- rxFactors(inData = df_sql, factorInfo = list(MS = list(levels = c("M","S"), otherLevel=NULL, varName="MaritalStatus")))</strong>
    <strong class="calibre1">            df_sql_r$Occupation &lt;- as.factor(df_sql_r$Occupation)</strong>
    <strong class="calibre1">            df_sql_r$MS &lt;- df_sql_r$MS</strong>
    <strong class="calibre1">            testData &lt;- data.frame(Occupation = df_sql_r$Occupation, Status=df_sql_r$MS)</strong>
    <strong class="calibre1">            d &lt;- rxCrossTabs(~Occupation:Status,  testData, returnXtabs = TRUE)</strong>
    <strong class="calibre1">            ken &lt;- rxKendallCor(d, type = "b")</strong>
    
    <strong class="calibre1">            k &lt;- ken$`estimate 1`</strong>
    <strong class="calibre1">            p &lt;- ken$`p-value`</strong>
    
    <strong class="calibre1">            #results</strong>
    <strong class="calibre1">            OutputDataSet &lt;- data.frame(k,p)'</strong>
    <strong class="calibre1">      ,@input_data_1 = N'</strong>
    <strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
    <strong class="calibre1">WITH RESULT SETS</strong>
    <strong class="calibre1">      ((</strong>
    <strong class="calibre1">             Kendall_value NVARCHAR(100)</strong>
    <strong class="calibre1">            ,Stat_significance NVARCHAR(100)</strong>
    <strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">许多其他原则可以用来计算变量之间的相关性。但这超出了本书的范围，因此我们只关注必要的内容。</p>
<p class="calibre2">预测建模的功能将在下一章介绍- <a target="_blank" href="part0096.html#2RHM00-e3f81285367248f4bbc6431bcd4f926d" class="calibre10">第6章</a>、<em class="calibre12">预测建模</em>。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Summary</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2QJ5E0-e3f81285367248f4bbc6431bcd4f926d" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">摘要</h1>
                
            
            
                
<p class="calibre2">本章涵盖了数据操作和数据争论的重要函数(以及其他许多函数)。这些步骤对于理解数据集的结构、数据集的内容以及数据是如何分布的是绝对重要的。这些主要用于理解频率、描述性统计以及一些统计抽样和统计相关性。</p>
<p class="calibre2">为了更好地理解数据，这些步骤必须在数据清理和数据合并之前完成。清理数据是最重要的，因为离群值可能会将敏感数据(或任何类型的数据)带到奇怪或错误的结论中:它还可能将结果转向其他方向。因此，通过使用强大的<kbd class="calibre11">rx</kbd> -函数(或类)将这些步骤视为非常重要，这应该是每个数据工程师、数据辩论者以及数据科学家的任务。下一章将关注用于预测建模的<kbd class="calibre11">RevoScaleR</kbd>函数，主要关注于创建模型和针对这些模型运行预测。</p>


            

            
        
    </body></html>
</body></html>