<html><head/><body><html><head><title>Chapter 7. Social Media Analysis – Analyzing Twitter Data</title><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>

<meta content="urn:uuid:cbb088e0-b938-4095-bde0-7154a8c2646b" name="Adept.expected.resource"/></head><body id="page"><div><div><div><div><h1 class="title"><a id="ch07"/>第七章。社交媒体分析——分析Twitter数据</h1></div></div></div><p>互联是描述21世纪T2生活的词。虽然各种因素促成了“联系”一词，但有一个方面起到了举足轻重的作用。它被称为<a class="indexterm" id="id506"/>网络。网络使距离成为无关紧要的衡量标准，模糊了社会经济界限，它本身就是一个世界，我们都是其中的一部分。尤其是网络或互联网已经成为这场数据驱动革命的核心实体。正如我们在前面的章节中所看到的，对于大多数现代问题，网络/互联网(此后可互换使用)充当了数据的来源。无论是电子商务平台还是金融领域，互联网每秒钟都为我们提供海量数据。在这个虚拟世界中还有另一个数据海洋，它在非常私人的层面上触及我们的生活。社交网络或社交媒体是信息的巨兽，也是本章的主题。</p><p>在前一章中，我们介绍了金融领域，在这里我们分析和预测了某家银行的客户的信用风险。我们现在转变方向，进入社交媒体领域，看看机器学习和R如何使我们能够从这一数据海洋中揭示洞察力。</p><p>在本章中，我们将讨论以下主题:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">社交网络的数据挖掘细节</li><li class="listitem" style="list-style-type: disc">不同数据可视化的重要性和用途</li><li class="listitem" style="list-style-type: disc">如何连接和收集Twitter数据的概述</li><li class="listitem" style="list-style-type: disc">利用Twitter数据揭示惊人的洞察力</li><li class="listitem" style="list-style-type: disc">了解社交网络如何给数据挖掘过程带来新的挑战</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec53"/>社交网络(推特)</h1></div></div></div><p>我们每天都在使用社交网络。有许多迎合各种意识形态和哲学的社交网络，但是脸书和推特(除了几个之外)已经成为社交网络本身的同义词。这两个社交网络之所以受欢迎，不仅因为它们的独特性和服务质量，还因为它们让我们能够以一种非常直观的方式进行互动。正如我们看到的电子商务网站中使用的推荐引擎(见<a class="link" href="ch04.html" title="Chapter 4. Building a Product Recommendation System">第四章</a>、<em>建立产品推荐系统</em>)，社交网络早在脸书、Twitter甚至互联网之前就已经存在了。</p><p>科学家和数学家都对社交网络感兴趣。它是一个跨学科的课题，跨越但不限于社会学、心理学、生物学、经济学、传播学和信息科学。已经开发了各种理论来分析社交网络及其对人类生活的影响，其形式为影响经济、人口统计、健康、语言、文化、犯罪等的因素。</p><p>早在19世纪晚期所做的研究形成了我们今天所称的社交网络的基础。正如这个词本身所说，社会网络是由人类和影响社会生活的元素所代表的节点或实体之间的一种连接/网络。更正式地说，它是一个描述关系和互动的网络。因此，看到各种图论和算法被用来理解社交网络并不令人惊讶。19世纪<sup>和20世纪<sup>局限于理论模型和艰苦的社会实验，而21世纪<sup>的技术已经为这些理论打开了大门，这些理论被测试、微调和建模，以帮助理解社会互动的动态。虽然通过一些社会网络(称为社会实验)来测试这些理论已经陷入了争议，但这些话题超出了本书的范围。我们将把自己限制在算法/数据科学领域，把争议留给专家去讨论。</sup></sup></sup></p><div><div><h3 class="title"><a id="note18"/>注意</h3><p>米尔格拉姆实验，或称小世界实验，是在20世纪60年代末进行的，目的是调查美国人的平均路径长度。作为这个实验的一部分，随机选择一些人作为邮件链的起点。这些随机的人被分派任务将邮件发送给下一个人，这样邮件就离它的目的地(波士顿的某个地方)更近了一步，以此类推。到目的地的平均六跳是这个著名实验的记录结果。都市民间传说暗示短语<em> 6度分隔</em>源自这个实验，尽管米尔格拉姆博士本人从未使用过这个术语！他进行了更多的实验；搜索并感到惊讶。</p><p>来源:</p><p><a class="ulink" href="http://www.simplypsychology.org/milgram.html">http://www.simplypsychology.org/milgram.html</a></p></div></div><p>在我们进入细节之前，让我们试着理解选择Twitter作为本章和下一章分析点的原因。让我们从理解Twitter是什么开始，为什么它如此受终端用户和数据科学家的欢迎。</p><p>众所周知，Twitter是一个社交网络/微博服务，它允许用户发送和接收最多140个字符的推文。但是Twitter如此受欢迎是因为它迎合了人类的基本本能。我们人类是好奇的生物，不断地需要被倾听。对我们来说，有个人或某个地方来表达我们的观点是很重要的。我们喜欢分享我们的经历、成就、失败和想法。在某种程度上，我们也想知道我们的同龄人在做什么，名人在忙什么，或者只是新闻报道。Twitter正好解决了这个问题。</p><p>早在Twitter出现之前，多种社交网络就已经存在，Twitter取代的不是其他服务。在我们看来，是Twitter组织信息的方式和点击它的用户。其独特的<em>追随</em>关系模式迎合了我们对好奇心的渴望，而其简短、免费、高速的交流平台使用户能够畅所欲言，并被全球听到。通过允许用户跟踪感兴趣的人或实体，它使我们能够跟上他们的最新动态，而无需其他用户跟踪我们。<em>追随</em>模式提示Twitter的关系更倾向于兴趣图，而不是通常在脸书等社交网络中发现的友谊模式。</p><p>Twitter因信息(和谣言)的超快速传播而闻名于世，并在全球范围内使用。它已经被创新性地用于某些以前无法想象的情况，例如在地震或台风等自然灾害发生时找人。它被用来传播信息，传播的广度和深度已经达到了病毒式传播的程度。不对称的关系和高速的信息交换有助于Twitter成为一个充满活力的实体。如果我们仔细分析和研究这个社交网络的数据和动态，我们可以发现许多见解。因此，这是本章的主题。</p><div><div><h3 class="title"><a id="note19"/>注意</h3><p><strong>有趣的链接</strong>:</p><p><a class="ulink" href="https://www.technologyreview.com/s/419368/how-twitter-helps-in-a-disaster/">https://www . technology review . com/s/419368/how-Twitter-helps-in-a-disaster/</a></p><p><a class="ulink" href="http://www.citylab.com/tech/2015/04/how-twitter-maps-can-be-useful-during-disasters/391436/">http://www . city lab . com/tech/2015/04/how-Twitter-maps-can-be-used-during-disasters/391436/</a></p><p><a class="ulink" href="https://www.researchgate.net/publication/282150020_A_Systematic_Literature_Review_of_Twitter_Research_from_a_Socio-Political_Revolution_Perspective?channel=doi&amp;linkId=56050b3f08ae5e8e3f3125cb&amp;showFulltext=true">https://www . Research gate . net/publication/282150020 _ A _ Systematic _ Literature _ Review _ of _ Twitter _ Research _ from _ A _ social-Political _ Revolution _ Perspective？channel = doi&amp;linkId = 56050 B3 f 08 AE 5 e8e 3f 3125 CB&amp;show full text = true</a></p><p><a class="ulink" href="http://www.tandfonline.com/doi/abs/10.1080/1369118X.2012.696123">http://www . tandfonline . com/doi/ABS/10.1080/1369118 x . 2012 . 696123</a></p><p><a class="ulink" href="http://www.psmag.com/nature-and-technology/how-to-use-social-media-usefully">http://www . PS mag . com/nature-and-technology/how-to-use-social-media-usefully</a></p></div></div><p>让我们使用# RMachineLearningByExample将一些<a class="indexterm" id="id511"/>数据科学应用到推文中！</p></div></div></body></html>
<html><head><title>Data mining @social networks</title><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>

<meta content="urn:uuid:cbb088e0-b938-4095-bde0-7154a8c2646b" name="Adept.expected.resource"/></head><body id="page"><div><div><div><div><h1 class="title"><a id="ch07lvl1sec54"/>数据挖掘@社交网络</h1></div></div></div><p>到目前为止，我们已经阅读了本书的章节，理解了各种概念，学习了一些令人惊叹的算法。我们甚至参与了在日常生活中有应用的项目。简而言之，我们在没有明确使用这个术语的情况下完成了数据挖掘。现在让我们借此机会正式定义数据挖掘。</p><p>采矿，在这个词的经典意义上，是指从地球上提取有用的矿物质(如采煤)。在信息时代的背景下，挖掘是指从大量数据中提取有用的信息。因此，如果我们仔细观察，<strong>知识</strong> <a class="indexterm" id="id513"/> <strong>挖掘</strong>或<strong>从</strong> <a class="indexterm" id="id514"/> <strong>数据</strong> ( <strong> KDD </strong>)中发现知识似乎是比数据挖掘这个术语更好的表述。和许多关键词一样，简短和甜蜜吸引了人们的注意力。因此，您可能会在许多地方发现从数据中发现知识和数据挖掘这两个术语可以互换使用，这是正确的。数据挖掘过程类似于矿物开采，包括以下步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">数据清理，去除噪音和不需要的数据</li><li class="listitem">数据转换将数据转换成相关的形式以供分析</li><li class="listitem">数据/模式评估揭示有趣的见解</li><li class="listitem">以有用的形式可视化知识的数据呈现</li></ol></div><div><div><h3 class="title"><a id="note20"/>注意</h3><p>数据挖掘不是使用搜索引擎来获取信息，比如关于蛇的信息。相反，它是关于揭示隐藏的洞察力，就像蛇是除了南极洲之外在每个大陆上发现的唯一的生物！</p></div></div><p>如果我们花一分钟来理解前面的步骤，我们可以看到我们在我们的项目中使用了完全相同的过程。请记住，我们只是形式化并介绍了我们在各个章节中遵循的流程，并没有遗漏或修改之前章节中完成的任何步骤。</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec67"/>挖掘社交网络数据</h2></div></div></div><p>既然我们已经正式定义了数据挖掘，并且看到了将数据转化为知识所涉及的步骤，让我们来关注来自社交网络的数据。虽然数据挖掘方法独立于数据源，但要记住某些事情，这可能会导致更好的处理和改进的结果。</p><p>像挖掘任何其他类型的数据一样，领域知识对于挖掘社交网络数据来说绝对是一个优势。尽管社会网络分析是一个跨学科的课题(如前一节所讨论的)，但它主要涉及与用户或实体及其交互相关的数据分析。</p><p>在前面的章节中，我们已经看到了各种各样的数据，从电子商务平台到银行，再到与鲜花特性相关的数据。我们看到的数据具有不同的属性和特征。但是如果我们仔细观察，这些数据是某种测量或事件捕获的结果。</p><p>进入社交网络的领域，游戏场有点不同，如果不是完全不同的话。与我们目前所看到的不同，来自社交媒体平台的数据极具动态性。当我们说动态时，我们指的是数据点上的实际内容，而不是它的结构。数据点本身可能是(也可能不是)结构化的，但内容本身不是。</p><p>让我们具体地谈谈一条推文中包含的数据。一条示例推文如下所示:</p><div><img alt="Mining social network data" src="img/B03459_07_01.jpg"/><div><p>图片来源:【https://twitter.com/POTUS/status/680464195993911296 T4】</p></div></div><p>众所周知，一条推文包含140个字符。由于消息是由用户生成的(通常)，实际的消息可能具有不同的长度、语言，或者它可能包含图像、链接、视频等等。因此，一条tweet是一个结构化的数据点，它包含用户的句柄(<code class="literal">@POTUS</code>)、用户的名字(<code class="literal">President Obama</code>)、消息(<code class="literal">From the Obama family...</code>)，以及与它何时被tweet相关的信息(<code class="literal">26 Dec 2015</code>)、点赞数和转发数。一条推文还可能包含嵌入在消息中的标签、超链接、图像和视频。正如我们将在接下来的章节中看到的，除了前面讨论的属性之外，一条tweet还包含大量元数据(关于数据的数据)。同样，来自其他社交网络的数据也包含了比通常看到的更多的信息。</p><p>来自一条推文的如此多的信息，加上全球数百万用户每秒钟疯狂地发推文，呈现了大量的数据，其中有有趣的模式等待被发现。</p><p>从真正的意义上来说，Twitter的数据(以及一般社交网络的数据)很好地代表了大数据的3v(数量、多样性和速度)。</p><div><div><h3 class="title"><a id="note21"/>注意</h3><p>每秒143，199条推文是2013年8月3日电影《空中楼阁》在日本播出时创下的纪录。平均每秒的推文通常在5700条左右；记录翻了25倍！在Twitter博客上了解更多信息:<a class="ulink" href="https://blog.twitter.com/2013/new-tweets-per-second-record-and-how">https://blog . Twitter . com/2013/new-tweets-per-second-record-and-how</a></p></div></div><p>因此，从社交网络中挖掘数据需要了解数据点的结构、潜在的哲学或社交网络的使用(Twitter用于快速交换信息，而LinkedIn用于专业网络)、生成数据的速度和数量，以及数据科学家的思维极限。</p><p>在本章的最后，我们还将触及社交网络对通常的挖掘方法提出的挑战。</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec68"/>数据和可视化</h2></div></div></div><p>当<a class="indexterm" id="id517"/>数据量每分钟都呈指数级增长时，数据挖掘活动的结果必须使决策者能够快速确定行动点。结果应该没有噪音/多余的信息，但足够清晰和完整以供使用。</p><p>以最方便、最有用的形式呈现信息以供目标受众(可能是非技术性的)轻松使用，这是数据挖掘过程的一个重要方面。到目前为止，在本书中，我们已经分析了数据，并利用折线图、条形图、直方图和散点图来揭示和展示见解。在我们使用这些以及本章中更多的可视化/图表之前，让我们试着理解它们的重要性并明智地使用它们。</p><p>在进行数据挖掘任务时，我们通常会全神贯注于数据、其复杂性、算法等等，以至于我们往往会忽略必须使结果可消费而不是难以阅读的数字和术语的部分。除了确保最终报告/文件包含正确且经过验证的数字之外，我们还需要确保这些数字的呈现方式便于最终用户使用。为了能够方便地使用这些信息/知识，我们借助了不同的可视化技术。</p><p>由于这不是一本关于可视化的<a class="indexterm" id="id518"/>书，我们冒昧地跳过了通常的线图、条形图、饼图、直方图和其他细节。在接下来的章节中使用可视化之前，让我们先了解一些非常规但广为人知/被广泛使用的可视化。</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec20"/>字云</h3></div></div></div><p>社交网络以不同的形式和格式生成数据。这些平台上的数据可以以各种不同的方式被创建、共享、修改、引用或使用。为了表示复杂的关系，社交网络数据最广泛使用的可视化方法之一是<strong>标签</strong> <a class="indexterm" id="id520"/> <strong>云</strong>或<strong>单词云</strong>。例如，这些平台上的文本、图像、视频和博客等对象经常被标记。因此，标签云/词云表示用户生成的标签的统计。这些标签可以表示单词使用的相对频率或它们在多个对象中的存在。使用不同的字体大小和颜色来区分单词/标签，以表示选择的统计数据(主要是频率)。</p><div><img alt="Word clouds" src="img/B03459_07_02.jpg"/><div><p>一个词云，描述了推特子集中的常用词</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec21"/>树形图</h3></div></div></div><p>为了表示高维度的数据，通常不可能同时可视化所有维度。树形图就是这样一种可视化类型，它将所有维度划分为子集，并以分层的方式呈现它们。具体来说，treemaps将维度划分为一组嵌套的矩形。一个被广泛引用的树形图的例子是newsmap，它将谷歌新闻聚合的新闻可视化，并用不同的颜色显示在不同的类别中；颜色梯度表示文章的外观(在时间尺度上)，而矩形的大小表示新闻项目的受欢迎程度。</p><div><img alt="Treemaps" src="img/B03459_07_03.jpg"/><div><p>显示由谷歌新闻聚合的新闻的树形图</p><p>图片来源:<a class="ulink" href="http://newsmap.jp/">http://newsmap.jp/</a></p></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec22"/>面向像素的地图</h3></div></div></div><p>可视化不仅使结果更容易理解，而且非常实用。大多数时候，分析过程的结果是多维的。在二维屏幕/纸上用图形表示这些数据是一个挑战。这就是面向像素的可视化的用武之地。对于一个<em> n维</em>数据集，面向像素的可视化将每个<em> n维</em>数据点映射到<em> n </em>不同子窗口中的单个像素。因此，每个数据点被分割成n个T21窗口，每个维度一个。这些帮助我们在单个可视化中映射大量数据。面向像素的可视化如下所示:</p><div><img alt="Pixel-oriented maps" src="img/B03459_07_04.jpg"/><div><p>面向像素的地图示例</p><p>图片来源:<a class="ulink" href="http://bib.dbvis.de/uploadedFiles/163.pdf">http://bib.dbvis.de/uploadedFiles/163.pdf</a></p></div></div></div><div><div><div><div><h3 class="title">其他可视化效果</h3></div></div></div><p>除了已经提到的可视化之外，还有许多其他有趣的可视化，它们对于不同的用例非常有用。例如，箱线图等可视化工具对于理解数据分布和异常值检测非常有用。类似地，还有一些可视化工具，如Chernoff面、散点图、网络图等等，它们都有自己的优点和使用案例。</p><p>请注意，可视化本身就是一个研究领域，这一部分只是试图触及冰山一角。我们敦促读者浏览本章<em>参考文献</em>部分分享的书籍/在线内容，以了解更多相关信息。</p></div></div></div></body></html>
<html><head><title>Getting started with Twitter APIs</title><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>

<meta content="urn:uuid:cbb088e0-b938-4095-bde0-7154a8c2646b" name="Adept.expected.resource"/></head><body id="page"><div><div><div><div><h1 class="title">【Twitter APIs入门</h1></div></div></div><p>Twitter对于tweeple(使用Twitter发微博的人)和数据科学家来说都是一种享受。API和文档都得到了很好的更新，并且易于使用。让我们从API开始吧。</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec69"/>概述</h2></div></div></div><p>Twitter拥有所有社交网络中最简单最强大的API。Twitter本身和数据科学家已经使用这些API来了解Twitter世界的动态。Twitter APIs使用四种不同的对象，即:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">推文:推文是定义Twitter本身的核心实体。正如上一节所讨论的，一条推文包含的信息(元数据)远不止是推文的内容/消息。</li><li class="listitem" style="list-style-type: disc"><strong>用户</strong>:任何可以发微博、关注或执行任何Twitter行为的人或事物都是用户。Twitter在用户定义上是独一无二的，用户不一定是人类。就是这样一个非人类的受欢迎的Twitter账号，拥有超过200万粉丝！</li><li class="listitem" style="list-style-type: disc"><strong>实体</strong>:这些是从tweet对象本身提取的结构化信息。这些信息可能包括URL、标签、用户提及等等。这些对象可以在不解析tweet文本的情况下实现更快的处理。</li><li class="listitem" style="list-style-type: disc"><strong>地点</strong>:一条推文也可能附带位置。这些信息可能用于各种目的，例如显示您附近的<em>趋势话题</em>或有针对性的营销。</li></ul></div><p>Twitter APIs中的上述对象已经在https://dev.twitter.com/网站上详细解释过了。我们敦促读者通读它，以便更好地理解对象和API。</p><p>Twitter拥有所有主流编程语言/平台的库。我们将利用Twitter，也就是TwitteR的r库。</p><div><div><h3 class="title"><a id="tip05"/>提示</h3><p><strong> Twitter最佳实践</strong></p><p>Twitter在其开发者网站<a class="ulink" href="https://dev.twitter.com/">https://dev.twitter.com/</a>上有一套<em>最佳实践</em>和一系列明确规定的该做和不该做的事情，该网站讨论了安全/认证、隐私等等。由于Twitter以高可用性支持庞大的客户群，它还跟踪其API的使用情况，以保持系统健康。他们的API被查询的次数有一个规定的速率限制。请浏览最佳实践并成为一名<code class="literal">#gooddeveloper</code>！</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>注册应用程序</h2></div></div></div><p>既然我们已经有了足够的关于Twitter和它的API对象的背景知识，让我们开始动手吧。开始使用API的第一步是<a class="indexterm" id="id529"/>通知Twitter你的应用程序。Twitter使用标准的<strong>开放认证</strong> ( <strong> OAuth </strong>)协议来授权第三方应用。OAuth使用应用程序的消费者密钥、消费者秘密、访问令牌和访问令牌秘密来允许它使用API和所连接服务的数据。</p><p>以下快速步骤将为我们的游戏做好准备:</p><div><ol class="orderedlist arabic"><li class="listitem">去https://apps.twitter.com/的Twitter应用管理控制台用你的证书登录，如果你没有的话，创建一个账户。</li><li class="listitem">点击<strong>创建新应用</strong>，填写应用名称、网站等详细信息。出于我们的目的，我们将把我们的应用程序命名为<code class="literal">TwitterAnalysis_rmre</code>。对于回调URL，使用<code class="literal">http://127.0.0.1:1410</code>来指向您的本地系统。您也可以选择任何其他端口号。</li><li class="listitem">点击<strong>创建您的Twitter应用程序</strong>以完成该过程。<a class="indexterm" id="id530"/>你的应用管理控制台看起来会像下面的截图:<div><img alt="Registering the application" src="img/B03459_07_05.jpg"/><div><p>Twitter应用页面</p> </div> </div></li></ol></div><p>恭喜您，您的应用程序已创建并注册到Twitter。但是在我们使用它之前，还有一个环节。我们需要创建访问令牌，为此我们执行以下步骤。</p><div><ol class="orderedlist arabic"><li class="listitem">转到Twitter应用程序详细信息页面上的链接<strong>密钥和访问令牌</strong>。</li><li class="listitem">向下滚动并点击<strong>创建我的访问令牌</strong>为您的个人资料生成一个访问令牌。</li><li class="listitem">完成上述步骤后，<strong>密钥和访问令牌</strong>页面如下图所示:<div> <img alt="Registering the application" src="img/B03459_07_06.jpg"/> <div> <p>应用密钥和访问令牌</p> </div> </div></li></ol></div><p>我们将在这一章以及下一章中使用<a class="indexterm" id="id531"/>相同的应用程序。记下消费者密钥、消费者秘密、访问令牌和访问秘密；我们将需要这些在我们的应用程序中。</p><div><div><h3 class="title"><a id="note22"/>注意</h3><p>为OAuth生成的密钥和秘密是敏感的信息。它们使你的应用程序能够访问Twitter的数据。请像保管密码一样保管好它们(甚至更安全)。<code class="literal">#SafetyFirst</code>。</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec71"/>连接/认证</h2></div></div></div><p>现在我们已经在Twitter端准备好了一切，让我们也在R端设置一些东西。在我们开始处理来自Twitter的数据之前，第一步是通过我们刚刚使用r创建的应用程序连接和验证我们自己。</p><p>我们将利用杰夫·金特里的R的TwitteR库。这个库或客户端允许我们通过r使用Twitter的web APIs。我们将使用方法<code class="literal">setup_twitter_oauth()</code>使用我们应用程序的凭证(密钥和访问令牌)连接到Twitter。请将以下代码中的<code class="literal">XXXX</code>替换为您在上一步中生成的访问密钥/令牌:</p><div><pre class="programlisting">

<strong>&gt; # load library</strong>

<strong>&gt; library(twitteR)</strong>

<strong>&gt; # set credentials</strong>

<strong>&gt; consumerSecret = "XXXXXXXXXXXXX"</strong>

<strong>&gt; consumerKey = "XXXXXXXXXXXXXXXXXXXXXXXXXx"</strong>

</pre></div><p>在执行前面的<a class="indexterm" id="id533"/>代码片段时，它会提示您是否使用本地文件来缓存凭证。现在，我们将对它说<code class="literal">No</code>:</p><p><img alt="Connect/authenticate" src="img/B03459_07_07.jpg"/></p><p>这将打开您的浏览器，并要求您使用您的Twitter凭据登录并授权此应用程序，如以下屏幕截图所示:</p><div><img alt="Connect/authenticate" src="img/B03459_07_08.jpg"/><div><p>授权应用程序获取数据</p></div></div><p>一旦授权，浏览器将被重定向到我们在Twitter上创建应用程序时提到的回调URL。您也可以为用户使用信息更丰富的URL。</p><div><img alt="Connect/authenticate" src="img/B03459_07_09.jpg"/></div><p>恭喜你，你现在已经连接到推文的海洋了。</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec72"/>提取样本推文</h2></div></div></div><p>现在我们已经使用R连接到Twitter，是时候提取一些最新的tweets并分析我们得到的信息了。为了提取推文，我们将使用Twitter的帐户001 (Twitter的创始人和第一个用户)，杰克·多西，<code class="literal">@jack</code>的句柄。以下代码片段摘录了他最近的300条推文:</p><div><pre class="programlisting">

<strong>&gt; twitterUser &lt;- getUser("jack")</strong>

<strong>&gt; # extract jack's tweets</strong>

<strong>&gt; tweets &lt;- userTimeline(twitterUser, n = 300)</strong>

<strong>&gt; tweets</strong>

</pre></div><p>由于Twitter的内容丰富的数据，输出包含文本以及不可打印的字符和URL。我们稍后将查看一条推文的元数据，但在此之前，提取的信息如下所示:</p><div><img alt="Extracting sample tweets" src="img/B03459_07_10.jpg"/><div><p>样本推文</p></div></div><p>要查看可用于分析和操作每条tweet的属性和函数，请使用如下的<code class="literal">getClass</code>方法:</p><div><pre class="programlisting">

<strong>&gt; # get tweet attributes</strong>

<strong>&gt; tweets[[1]]$getClass()</strong>

<strong>&gt;</strong>

<strong>&gt; # get retweets count</strong>

<strong>&gt; tweets[[1]]$retweetCount</strong>

<strong>&gt;</strong>

<strong>&gt; # get favourite count</strong>

<strong>&gt; tweets[[1]]$favoriteCount</strong>

</pre></div><p>将生成以下输出:</p><div><img alt="Extracting sample tweets" src="img/B03459_07_11.jpg"/></div></div></div></body></html>
<html><head><title>Twitter data mining</title><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>

<meta content="urn:uuid:cbb088e0-b938-4095-bde0-7154a8c2646b" name="Adept.expected.resource"/></head><body id="page"><div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>推特数据挖掘</h1></div></div></div><p>既然我们已经测试了我们的工具、库和与Twitter APIs的连接，是时候开始寻找Twitter土地上隐藏的宝藏了。让我们戴上数据矿工帽，开始挖掘吧！</p><p>在这一部分，我们将处理从搜索关键词(或Twitter词汇表中的标签)和用户时间表中收集的Twitter数据。利用这些数据，我们将在使用TwitteR和其他R包的不同功能和实用程序时发现一些有趣的见解。</p><div><div><h3 class="title"><a id="note23"/>注意</h3><p>请注意，我们的过程将隐含地遵循数据挖掘概述的步骤。本着简洁的精神，我们可能会冒昧地不明确提到每一个步骤。我们在挖掘一些<em>镀金</em>的真知灼见；请放心，没有遗漏任何内容！</p></div></div><p>每一年，我们都怀着新的热情去完成伟大的壮举，并改进我们的缺点。我们大多数人都以新年决心的形式对自己做出承诺。让我们一起来探索tweeple在2016年都在做些什么吧！</p><div><div><h3 class="title"><a id="note24"/>注意</h3><p><strong>注意</strong> : Twitter数据变化非常快，您的结果/图表可能与本章描述的有所不同。</p></div></div><p>我们将使用同一个应用程序及其凭证来连接并接入Twitter获取数据。以下代码的工作方式与我们在上一节中提取的样本tweets完全相同:</p><div><pre class="programlisting">

<strong>library(twitteR)</strong>

<strong>library(ggplot2)</strong>

<strong>library(stringr)</strong>

<strong>library(tm)</strong>

<strong>library(wordcloud)</strong>



<strong>consumerSecret = "XXXXXXXXX"</strong>

<strong>consumerKey = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</strong>



<strong>setup_twitter_oauth(consumer_key = consumerKey,consumer_secret = consumerSecret)</strong>

</pre></div><p>除了连接Twitter，我们还加载了所需的包，如<code class="literal">ggplot</code>、<code class="literal">stringr</code>、<code class="literal">tm</code>和<code class="literal">wordcloud</code>。随着我们的继续，我们将看到这些包在哪里以及如何有用。</p><p>一旦连接到我们的数据源，我们就可以开始收集所需的数据。由于我们计划了解tweeple和他们的新年决心，我们将为标签<code class="literal">#ResolutionsFor2016</code>提取数据。我们也可以使用任何标签，比如<code class="literal">#NewYearResolutions</code>、<code class="literal">#2016Resolutions</code>，或者标签的组合来获取相关的推文。下面这段代码不仅提取tweet，还将tweet/status对象的列表转换成R数据帧。我们还将每条推文转换成UTF 8，以处理不同语言的文本。</p><div><div><h3 class="title"><a id="note25"/>注意</h3><p>惊人的事实:Twitter有48种不同的语言版本，而且还在增加！</p></div></div><div><pre class="programlisting">

<strong># trending tweets</strong>

<strong>trendingTweets = searchTwitter("#ResolutionsFor2016",n=1000)</strong>

<strong>trendingTweets.df = twListToDF(trendingTweets)</strong>

<strong>trendingTweets.df$text &lt;- sapply(trendingTweets.df$text,function(x) iconv(x,to='UTF-8'))</strong>

</pre></div><p>正如我们在上一节中看到的，一条tweet包含的信息远不止文本。各种属性之一是状态源。状态源表示发出推文的设备。可能是手机，平板，等等。在应用主要转换和清理tweet对象之前，我们应用一个快速转换将状态源转换为有意义的形式:</p><div><pre class="programlisting">

<strong>trendingTweets.df$tweetSource = sapply(trendingTweets.df$statusSource,function(sourceSystem) enodeSource(sourceSystem))</strong>

</pre></div><p>前面的代码将<code class="literal">statusSource</code>从值<code class="literal">&lt;a href=\"http://twitter.com/download/android\" rel=\"nofollow\"&gt;Twitter for Android&lt;/a&gt;</code>转换为简单的Android，并将其赋给一个名为<code class="literal">tweetSource</code>的新属性。</p><p>一旦我们有了数据，数据挖掘过程的下一步就是清理数据。我们使用文本挖掘包<code class="literal">tm</code>来执行转换和清理。特别是<code class="literal">Corpus</code>函数帮助我们将tweet/status对象作为文档集合进行处理。然后，我们使用同一个包中的<code class="literal">tm_map</code>实用程序来应用/映射转换，例如将所有文本转换为小写，删除标点符号、数字和停用词。停用字词是最常用字词的列表，如a、an、the等，在分析文本时可以安全地将其删除，而不会失去意义。</p><div><pre class="programlisting">

<strong># transformations</strong>

<strong>tweetCorpus &lt;- Corpus(VectorSource(trendingTweets.df$text))</strong>

<strong>tweetCorpus &lt;- tm_map(tweetCorpus, tolower)</strong>

<strong>tweetCorpus &lt;- tm_map(tweetCorpus, removePunctuation)</strong>

<strong>tweetCorpus &lt;- tm_map(tweetCorpus, removeNumbers)</strong>



<strong># remove URLs</strong>

<strong>removeURL &lt;- function(x) gsub("http[[:alnum:]]*", "", x)</strong>

<strong>tweetCorpus &lt;- tm_map(tweetCorpus, removeURL) </strong>



<strong># remove stop words</strong>

<strong>twtrStopWords &lt;- c(stopwords("english"),'resolution','resolutions','resolutionsfor','resolutionsfor2016','2016','new','year','years','newyearresolution')</strong>

<strong>tweetCorpus &lt;- tm_map(tweetCorpus, removeWords, twtrStopWords)</strong>



<strong>tweetCorpus &lt;- tm_map(tweetCorpus, PlainTextDocument)</strong>

</pre></div><p>在我们继续下一步分析隐藏模式/见解的数据之前，最后的转换是一个术语-文档矩阵。顾名思义，术语-文档矩阵是一种矩阵表示，其中术语作为行，而列由文档表示。该矩阵中的每个条目代表一个术语在给定文档中出现的次数。更正式地说，术语-文档矩阵是描述术语在文档集合中的频率的矩阵表示。这种表示在自然语言处理应用程序中非常有用。它是一种优化的数据结构，支持快速搜索、主题建模等等。可以使用下面的简单例子来解释数据结构，其中我们有两个文本文档，<strong> TD1 </strong>和<strong> TD2 </strong>:</p><div><img alt="Twitter data mining" src="img/B03459_07_12.jpg"/><div><p>样本术语-文档矩阵</p></div></div><p>tm包为<a class="indexterm" id="id539"/>我们提供了另一个简单易用的工具，叫做term-document matrix ( <code class="literal">TermDocumentMatrix</code>也是可用的)，我们用它将<code class="literal">Corpus</code>对象转换成所需的形式:</p><div><pre class="programlisting">

<strong># Term Document Matrix</strong>

<strong>&gt; twtrTermDocMatrix &lt;- TermDocumentMatrix(tweetCorpus, control = list(minWordLength = 1))</strong>

</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec73"/>常用词和联想</h2></div></div></div><p>这样准备的<a class="indexterm" id="id540"/>术语-文档矩阵以行的形式包含了来自每条tweet(发布清理和转换)的单词，而列代表tweet本身。</p><p>作为快速检查，让我们看看哪些单词在我们的数据集中使用得最频繁。将阈值设置为<code class="literal">30</code>次或更多次。我们使用apply实用程序迭代术语文档矩阵中的每个术语，并对其出现次数求和。该函数帮助我们筛选出出现30次或更多次的术语。</p><div><pre class="programlisting">

<strong># Terms occuring in more than 30 times</strong>

<strong>&gt; which(apply(twtrTermDocMatrix,1,sum)&gt;=30)</strong>

</pre></div><p>结果将如下面的截图所示:</p><div><img alt="Frequent words and associations" src="img/B03459_07_13.jpg"/><div><p>在推文中出现30次或更多的术语</p></div></div><p>如前面的屏幕截图所示，单词列表中出现了30个或更多的单词，如健康、激励和积极。谈到年度目标，我们都有很多共同点，不是吗？</p><p>前面的操作是一个快速检查，看看我们是否真的有tweets来帮助我们发现一些关于新年决心的有趣事情。现在让我们采取一种正式的方法，并确定我们的数据集中的常用术语。我们还将尝试以一种有创意且易于理解的方式展示信息<a class="indexterm" id="id541"/>。为了获得数据集中最常见的术语，我们再次使用了来自<code class="literal">tm</code>包的函数<code class="literal">findFreqTerms</code>。这个函数为我们提供了快速破解的抽象，比如我们之前使用的那个。<code class="literal">findFreqTerms</code>还让我们为术语频率设置最小和最大阈值。对于我们的情况，我们将只提及下限并查看结果:</p><div><pre class="programlisting">

<strong># print the frequent terms from termdocmatrix</strong>

<strong>&gt; (frequentTerms&lt;-findFreqTerms(twtrTermDocMatrix,lowfreq = 10))</strong>

</pre></div><p>结果类似于下面的截图:</p><p><img alt="Frequent words and associations" src="img/B03459_07_14.jpg"/></p><p>我们得到大约107个词，最少出现10个。如果你仔细观察，我们看到的出现频率至少为30的术语也出现在这个列表中，这是理所当然的。</p><p>既然我们已经确定有出现次数超过10次的术语/单词，那么让我们创建一个数据框，并按照我们之前的决定绘制术语与其频率的关系图。我们使用<code class="literal">rowSums</code>函数来计算每个术语/单词的总出现次数。然后我们<a class="indexterm" id="id542"/>选择出现次数超过10次的术语子集，并使用<code class="literal">ggplot</code>绘制它们:</p><div><pre class="programlisting">

<strong># calculate frequency of each term</strong>

<strong>term.freq &lt;- rowSums(as.matrix(twtrTermDocMatrix))</strong>



<strong># picking only a subset</strong>

<strong>subsetterm.freq &lt;- subset(term.freq, term.freq &gt;= 10)</strong>





<strong># create data frame from subset of terms</strong>

<strong>frequentTermsSubsetDF &lt;- data.frame(term = names(subsetterm.freq), freq = subsetterm.freq)</strong>



<strong># create data frame with all terms</strong>

<strong>frequentTermsDF &lt;- data.frame(term = names(term.freq), freq = term.freq)</strong>



<strong># sort by subset DataFrame frequency</strong>

<strong>frequentTermsSubsetDF &lt;- frequentTermsSubsetDF[with(frequentTermsSubsetDF, order(-frequentTermsSubsetDF$freq)), ]</strong>



<strong># sort by complete DataFrame frequency</strong>

<strong>frequentTermsDF &lt;- frequentTermsDF[with(frequentTermsDF, order(-frequentTermsDF$freq)), ]</strong>



<strong># words by frequency from subset data frame</strong>

<strong>ggplot(frequentTermsSubsetDF, aes(x = reorder(term,freq), y = freq)) + geom_bar(stat = "identity") +xlab("Terms") + ylab("Frequency") + coord_flip()</strong>

</pre></div><p>前面的代码生成了下面的频率图:</p><div><img alt="Frequent words and associations" src="img/B03459_07_15.jpg"/></div><p>通过分析上图，我们可以很快发现一些有趣的地方:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>妈妈</strong>、<strong>当选</strong>、<strong>总统</strong>、<strong>万亿美元</strong>这几个词出现在前10名中。奇怪的场景，但很有趣。稍后会有更多的介绍。</li><li class="listitem" style="list-style-type: disc">健康在列表中排名很高，但没有进入前10名。所以，看起来健康是有可能的，但不是很高。这同样适用于<strong>健身</strong>和<strong>饮食</strong>。</li><li class="listitem" style="list-style-type: disc">这个列表中的大多数单词本质上都是积极的。像<strong>快乐</strong>、<strong>希望</strong>、<strong>积极</strong>、<strong>改变</strong>等等词汇都指向在做新年决定时的乐观情绪！</li></ul></div><p>尽管前面的图表在一个漂亮的布局中给了我们相当多的关于单词及其频率的信息，但它仍然没有向我们展示全貌。还记得在生成此图之前，我们从数据集中精心制作了一个项目子集吗？我们是故意这样做的，否则图表会变得太长，出现频率较低的单词会使整个事情变得混乱。这张图漏掉的另一点是频率的相对差异。</p><p>如果我们的目标是看到频率之间的相对差异，我们需要一个完全不同的可视化。word cloud来拯救我们了。使用<code class="literal">wordcloud</code>库，我们可以很容易地使用一行代码从数据帧生成单词云:</p><div><pre class="programlisting">

<strong># wordcloud</strong>

<strong>&gt; wordcloud(words=frequentTermsDF$term, freq=frequentTermsDF$freq,random.order=FALSE)</strong>

</pre></div><p>使用完整数据框架的单词<a class="indexterm" id="id544"/>云看起来像这样:</p><div><img alt="Frequent words and associations" src="img/B03459_07_16.jpg"/></div><p>前面的单词云以频率递减的顺序呈现单词。每个单词的大小强调了它的频率。您可以使用<code class="literal">wordcloud</code>函数来生成一些有趣的可视化效果，甚至是艺术！</p><p>在前面的图表中出现了很多单词，但是看到单词万亿出现在前10名中不是很有趣吗？原因可能是什么？是一个机器人发的垃圾邮件，还是某个名人的推文迅速传播，还是完全不同的东西？让我们来看看这个列表中最热门的推文，看看它是否包含单词万亿美元:</p><div><pre class="programlisting">

<strong># top retweets</strong>

<strong>&gt; head(subset(trendingTweets.df$text, grepl("trillionaire",trendingTweets.df$text) ),n=1)</strong>

</pre></div><p>下面的截图是你得到的:</p><p><img alt="Frequent words and associations" src="img/B03459_07_17.jpg"/></p><p>事实证明，我们的预感是正确的。这是一个名人的新年决心推特，在网上疯传。在Twitter上快速搜索会发现这条推文:</p><div><img alt="Frequent words and associations" src="img/B03459_07_18.jpg"/><div><p>图片来源:【https://twitter.com/mishacollins?lang=en T4】</p></div></div><p>进一步搜索发现米沙·克林斯是电视剧《超自然》中的著名演员。我们还可以看到上面的决议被转发了惊人的5k次！有趣的是，点赞数为14k，超过了转发数。我们能推断出tweeple更喜欢喜欢/心而不是转发吗？还可以看出，像妈妈、学习、万亿美元、当选和总统这样的词毫无疑问都是出现频率最高的词。我们还可以间接推断出《超自然》在Twitter上拥有大量粉丝，卡西迪奥(米莎在电视剧中的角色)是该剧的热门角色。有点令人惊讶的是他决心学习钩针编织，不是吗？</p><p>离开超自然的东西，让我们回到健康的辩论。健康对我们大多数人来说都很重要。在一年的最初几个月/几周，锻炼或去健身房等活动会激增。让我们看看推特上的朋友们有多注重健康吧！</p><p>既然很多词如健康、饮食、健身、健身房等等都指向健康的生活方式，那么让我们试着找到与单词健身相关的词。<code class="literal">findAssocs</code>是一个方便的功能，它可以帮助我们从一个术语文档矩阵中找到与给定单词至少有特定相关性的单词。我们将使用这个函数的输出来准备一个使用<code class="literal">ggplot</code>的术语关联(相关性)图。该过程类似于我们如何准备前面的频率图:</p><div><pre class="programlisting">

<strong># Associatons</strong>

<strong>(fitness.associations &lt;- findAssocs(twtrTermDocMatrix,"fitness",0.25))</strong>



<strong>fitnessTerm.freq &lt;- rowSums(as.matrix(fitness.associations$fitness))</strong>



<strong>fitnessDF &lt;- data.frame(term=names(fitnessTerm.freq),freq=fitnessTerm.freq)</strong>



<strong>fitnessDF &lt;- fitnessDF[with(fitnessDF, order(-fitnessDF$freq)), ]</strong>

<strong>ggplot(fitnessDF,aes(x=reorder(term,freq),y=freq))</strong>

<strong>+geom_bar(stat = "identity") +xlab("Terms")</strong>

<strong>+ ylab("Associations")</strong>

<strong>+ coord_flip()</strong>

</pre></div><p>与单词fitness密切相关的单词most <a class="indexterm" id="id546"/>如下:</p><p><img alt="Frequent words and associations" src="img/B03459_07_19.jpg"/></p><p>同样的数据以图形的形式更具可读性，如下所示:</p><div><img alt="Frequent words and associations" src="img/B03459_07_20.jpg"/></div><p>从上图可以明显看出，诸如<strong>减肥</strong>、<strong>健身</strong>、<strong>健身</strong>等术语。证明我们的观点，十二个人和我们一样关心健康。有趣的是，在这个列表中出现了术语<em> yogavideos </em>。2016年，瑜伽似乎正在赶上其他保持健康的技巧。名单上还有冥想。</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec74"/>流行设备</h2></div></div></div><p>到目前为止，我们已经用<a class="indexterm" id="id547"/>处理了一条tweet的可见组件，比如文本、retweet计数等等，我们能够提取许多有趣的见解。让我们拿出我们的精密工具，更深入地挖掘我们的数据。</p><p>正如上面几节中多次提到的，一条推文包含的信息远比看上去的要多。一条这样的信息是关于推文的来源。Twitter诞生于短信时代，它的许多特征，比如140个字符的字数限制，都让人想起那个时代。看看tweeple是如何使用Twitter的会很有趣，也就是经常用什么设备访问和在Twitter上发帖。尽管这个世界已经从短信时代走了很长一段路，但手机无处不在。为了获得这个信息，我们将利用数据帧<code class="literal">trendingTweets.df</code>中的属性<code class="literal">tweetSource</code>。我们从已经存在于<code class="literal">tweet</code>对象中的<code class="literal">statusSource</code>属性中创建了这个附加属性(参见本节开头的快速回顾)。</p><p>为了清楚起见，我们将使用基于转发计数的数据帧<code class="literal">trendingTweets.df</code>的子集。我们将再次使用<code class="literal">ggplot</code>来可视化我们的结果。</p><div><pre class="programlisting">

<strong># Source by retweet count</strong>

<strong>trendingTweetsSubset.df &lt;- subset(trendingTweets.df, trendingTweets.df$retweetCount &gt;= 5000 )</strong>



<strong>ggplot(trendingTweetsSubset.df, aes(x =tweetSource, y =retweetCount/100)) + geom_bar(stat = "identity") +xlab("Source") + ylab("Retweet Count")</strong>

</pre></div><p>以下情节是你的结果:</p><div><img alt="Popular devices" src="img/B03459_07_21.jpg"/></div><p>毫无疑问，iPhone是最受欢迎的设备，其次是Android和网络。有趣的是，人们使用网络/网站转发的次数超过了iPad！Windows Phone显然有一些严重的问题需要解决。我们还能推断出iPhone是十二人中的首选设备吗？还是说iPhone为Twitter提供了比其他设备更好的体验？或者我们甚至可以更深入地说，iPhone上的Twitter有一个比任何其他设备都更容易访问的“转发”按钮。诸如此类的推论需要更多的挖掘，但所有这些都有很多知识/潜力，可以被管理层、UX团队等用来改善和改变周围的事情。</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec75"/>层次聚类</h2></div></div></div><p>我们已经<a class="indexterm" id="id549"/>在之前的章节中看到了聚类和分类(参见<a class="link" href="ch02.html" title="Chapter 2. Let's Help Machines Learn">第二章</a>、<em>让我们帮助机器学习</em>)，并揭示了一些关于手头数据的有趣事实。对于我们当前的用例，即使我们的推文都与2016年的决议相关，我们也永远无法确定tweeple做出的决议的类型。这使得它成为分层集群的一个非常合适的用例。与k-means或其他需要在计算前预设聚类数的聚类算法不同，层次聚类算法独立工作。</p><p>在将层次聚类应用于我们的数据之前，让我们借此机会了解一下层次聚类。与任何其他聚类算法一样，层次聚类帮助我们将相似的项目分组在一起。该算法的确切细节通常可以解释如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> Initialize </strong>:这是第一步，每个元素都被分配到自己的集群中。对于包含<em> n </em>个元素的数据集，该算法创建<em> n </em>个不同的聚类，每个聚类中有一个元素。在这一步确定距离/相似性度量。</li><li class="listitem" style="list-style-type: disc"><strong>合并</strong>:在这个步骤中，根据所选择的距离/相似性度量，最接近的一对聚类被识别并合并成单个聚类。这一步产生的聚类比目前的总聚类少一个。</li><li class="listitem" style="list-style-type: disc"><strong>计算</strong> / <strong>重新计算</strong>:我们计算/重新计算在合并步骤中形成的新聚类和现有聚类之间的距离/相似度。</li></ul></div><p>重复<strong>合并</strong>和<strong>计算</strong>步骤，直到我们剩下包含所有<em> n </em>项的单个集群。顾名思义，这种算法生成一个层次结构，叶子表示单个元素，当我们走向树根时，根据相似性/距离组合成簇。输出树通常被称为<a class="indexterm" id="id550"/> <strong>树状图</strong>。</p><p>合并步骤是该算法的变体所在。有几种方法可以识别最接近的聚类。从简单的方法(如单链法，该方法将两个聚类中任意两个元素之间的最短距离作为距离度量)到复杂的方法(如Ward的方法，该方法使用方差来寻找最紧密的聚类),有多种方法可供使用，具体取决于使用情况。</p><p>回到Twitter世界，让我们使用层次聚类来看看哪些术语/推文是最接近的。对于我们当前的用例，我们将使用单一方法作为我们的合并标准。您可以尝试不同的算法并观察其差异。</p><p>为了执行<a class="indexterm" id="id551"/>层次聚类，为了清楚起见，我们首先处理我们的数据集以去除稀疏项。为此，<code class="literal">removeSparseTerms</code>函数帮助我们删除稀疏度低于指定限制的数据行。然后我们使用<code class="literal">hclust</code>工具来形成集群。该实用程序的输出可直接绘图。让我们为此编写一些代码:</p><div><pre class="programlisting">

<strong># remove sparse terms</strong>

<strong>twtrTermDocMatrix2 &lt;- removeSparseTerms(twtrTermDocMatrix, sparse = 0.98)</strong>



<strong>tweet_matrix &lt;- as.matrix(twtrTermDocMatrix2)</strong>



<strong># cluster terms</strong>

<strong>distMatrix &lt;- dist(scale(tweet_matrix))</strong>



<strong>fit &lt;- hclust(distMatrix,method="single")</strong>

<strong>plot(fit)</strong>

</pre></div><p>输出的<em>树状图</em>非常简单易懂:</p><div><img alt="Hierarchical clustering" src="img/B03459_07_22.jpg"/></div><p>如果您观察右侧的第二个集群，它包含术语<strong>万亿元</strong>、<strong>当选</strong>、<strong>妈妈</strong>、<strong>调用</strong>等等。映射回米莎·柯林斯转发量最高的推文，所有这些术语都在那条推文中提到，我们的算法正确地将它们聚集在一起。很聪明，不是吗？作为一个小练习，观察其他集群，看看这些术语在包含它们的推文中是如何出现的。这里要做的一个重要观察是<em>树状图</em>正确地将所有常用术语映射到一个根下，这再次证明了所有这些术语<a class="indexterm" id="id552"/>都指向我们2016年决议的中心主题！</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec76"/>主题建模</h2></div></div></div><p>到目前为止，我们的<a class="indexterm" id="id553"/>分析是关于来自世界各地用户的与新年决心相关的推文。我们分析了与我们选择的主题相关的推文。忽略垃圾邮件和其他嘈杂的推文，我们的数据或多或少符合一个主题。这个主题本身由一组词(比如健康、万亿美元、健康、饮食、妈妈等等)组成，这些词概括地描述了不同的解决方案。为了扩大我们的分析范围和发现更多的见解，让我们来谈谈主题建模的概念。</p><p>主题建模是在代表语料库要点的未标记文本语料库中发现模式的过程。一个主题本身可以被描述为一组出现在一起的单词来描述一个大的文本。</p><p>另一个定义是在一次主题建模会议上发布的:</p><div><img alt="Topic modeling" src="img/B03459_07_23.jpg"/><div><p>图片来源:<a class="ulink" href="https://twitter.com/footnotesrising/status/264823621799780353">https://Twitter . com/footnotes rising/status/264823621799780353</a></p></div></div><p>主题建模的目的是自动识别语料库的潜在主题，从而在需要基于主题但缺乏已知关键字(与我们当前使用的搜索引擎完全相反)的信息检索的应用中有用。例如，通过使用主题<em>国家一和国家二</em>之间的关系，而不是搜索一个关键字，然后跟随一个又一个链接，从报纸的档案中了解两个国家之间的关系，这难道不令人惊讶吗？请注意，通过以下链接来发现信息也同样有效，但仍有许多不足之处。</p><p>进行主题建模的方式之一是通过<strong>潜在狄利克雷分配</strong>(<strong>LDA</strong>)；它是最强大和最广泛使用的模型之一。</p><p>LDA是由David M Blie在2003年的论文<em>概率主题模型简介</em>中提出的。正如他的论文所言，LDA可以被定义为一种生成模型，它允许未被观察到的群体解释观察集，从而解释为什么数据的某些部分是相似的。LDA的工作基于文档展示多个主题的假设。</p><p>LDA是一个概率模型，它的数学相当复杂，超出了本书的范围。以非数学的方式，LDA可以被解释为一种模型/过程，其帮助识别已经导致文档集合的生成的主题。</p><div><div><h3 class="title"><a id="note26"/>注意</h3><p>如需进一步阅读，请参考Blei的论文。</p><p><a class="ulink" href="https://www.cs.princeton.edu/~blei/papers/Blei2011.pdf">https://www.cs.princeton.edu/~blei/papers/Blei2011.pdf</a></p><p>用简单的语言解释一切的博客:</p><p><a class="ulink" href="http://tedunderwood.com/2012/04/07/topic-modeling-made-just-simple-enough/">http://tedunderwood . com/2012/04/07/topic-modeling-made-just-simple-after</a></p></div></div><p>对于我们的目的/用例，我们可以假设LDA是一个模型/过程，它帮助我们从未标记文本的语料库中识别潜在的(隐藏的/潜在的)主题。幸运的是，R以名为<code class="literal">topicmodels</code>的库的形式抽象了大部分数学细节。</p><p>出于主题建模的目的，我们将使用一组新的tweets。<strong>国际太空</strong> <a class="indexterm" id="id555"/> <strong>站</strong> ( <strong> ISS </strong>)有多个Twitter句柄，其中一个是<code class="literal">@ISS_Research</code>，专门迎合来自ISS的研究相关推文。让我们通过分析时间线上的推文来探究一下<code class="literal">@ISS_Research</code>最近在做什么。我们将分析这些推文，以确定国际空间站潜在的研究主题。为此，我们将使用与之前相同的流程来提取推文并执行转换/清理。以下代码片段实现了这一点:</p><div><pre class="programlisting">

<strong># set user handle</strong>

<strong>atISS &lt;- getUser("ISS_Research")</strong>



<strong># extract iss_research tweets</strong>

<strong>tweets &lt;- userTimeline(atISS, n = 1000)</strong>



<strong>tweets.df=twListToDF(tweets)</strong>



<strong>tweets.df$text &lt;- sapply(tweets.df$text,function(x) iconv(x,to='UTF-8'))</strong>



<strong>#Document Term Matrix</strong>

<strong>twtrDTM &lt;- DocumentTermMatrix(twtrCorpus, control = list(minWordLength = 1))</strong>

</pre></div><p>请注意，前面的代码片段准备了一个<em>文档-术语矩阵</em>，不像上次我们准备了一个<em>术语-文档矩阵</em>。</p><p>一旦我们有了所需格式的推文，来自<code class="literal">topicmodels</code>包的<code class="literal">LDA</code>实用程序可以帮助我们发现隐藏的主题/模式。LDA实用程序需要输入主题的数量以及文档术语矩阵。现在我们将尝试八个主题。下面的代码使用<code class="literal">LDA</code>为八个主题中的每一个提取六个术语:</p><div><pre class="programlisting">

<strong>#topic modeling</strong>



<strong># find 8 topics</strong>

<strong>ldaTopics &lt;- LDA(twtrDTM, k = 8) </strong>



<strong>#first 6 terms of every topic</strong>

<strong>ldaTerms &lt;- terms(ldaTopics, 6) </strong>



<strong># concatenate terms</strong>

<strong>(ldaTerms &lt;- apply(ldaTerms, MARGIN = 2, paste, collapse = ", "))</strong>

</pre></div><p>使用LDA生成的主题列表如下:</p><p><img alt="Topic modeling" src="img/B03459_07_24.jpg"/></p><p>视觉表现会更容易理解。我们可以利用<code class="literal">qplot</code>在面积图上快速绘制不同时间的主题，如下所示:</p><div><pre class="programlisting">

<strong># first topic identified for every tweet</strong>

<strong>firstTopic &lt;- topics(ldaTopics, 1)</strong>



<strong>topics &lt;- data.frame(date=as.Date(tweets.df$created), firstTopic)</strong>



<strong>qplot(date, ..count.., data=topics, geom="density",fill=ldaTerms[firstTopic], position="stack")+scale_fill_grey()</strong>

</pre></div><p>生成的图表如下图所示:</p><div><img alt="Topic modeling" src="img/B03459_07_25.jpg"/></div><p>现在让我们分析输出。LDA生成的每个主题的术语列表似乎让我们很好地了解了ISS正在进行的工作/研究。诸如火星、微重力、花、天鹅座等术语告诉我们研究的主要领域，或者至少是国际空间站上的科学家/宇航员正在谈论的主题<a class="indexterm" id="id557"/>。stationcdrkelly和astrotimpeake等术语看起来更像Twitter的句柄。</p><div><div><h3 class="title"><a id="note27"/>注</h3><p>一个快速的练习是使用当前的<code class="literal">@ISS_Research</code>时间线数据并挖掘句柄，例如<code class="literal">stationcdrkelly</code>，以发现更多信息。谁知道呢，这可能会是一个很好的宇航员名单！</p></div></div><p><code class="literal">qplot</code>输出将时间维度添加到我们的普通主题列表中。跨时间维度分析主题有助于我们理解何时讨论了某个特定的研究主题，或何时宣布了令人惊讶的事情。列表中的主题二，或者图形图例中从顶部数第四个主题包括单词flower。由于科学家们最近成功地在太空中开放了一些橙色的花朵，上面的图表帮助我们了解到这条消息是在1月15日<sup>左右</sup>在Twitter上首次爆出的。在Twitter/新闻网站上快速浏览一下，证实了这条消息是在2016年1月18日<sup>通过tweet爆料的……够接近了！</sup></p><div><div><h3 class="title"><a id="tip06"/>提示</h3><p><strong>彩色面积图</strong></p><p>试着从<code class="literal">qplot</code>中去掉选项<code class="literal">scale_fill_grey()</code>，得到一些比普通灰度更容易阅读的漂亮图表。</p></div></div><p>因此，最终我们了解了使用LDA对来自国际空间站的数据进行主题建模，并发现了科学家和宇航员在外太空正在做的惊人的事情。</p></div></div></body></html>
<html><head><title>Challenges with social network data mining</title><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>

<meta content="urn:uuid:cbb088e0-b938-4095-bde0-7154a8c2646b" name="Adept.expected.resource"/></head><body id="page"><div><div><div><div><h1 class="title"><a id="ch07lvl1sec57"/>社交网络数据挖掘的挑战</h1></div></div></div><p>在我们结束第<a class="indexterm" id="id559"/>章之前，让我们看看社交网络对数据挖掘过程提出的不同挑战。以下几点提出了一些论点、问题和挑战:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">毫无疑问，社交网络产生的数据在各个方面都属于大数据。它拥有压倒任何系统的所有容量、速度和多样性。然而，有趣的是，如此庞大的数据源面临的挑战是足够细粒度数据的可用性。如果我们放大我们的数据集，并尝试在每个用户的基础上使用数据，我们会发现没有足够的数据来完成一些最常见的任务，如提出建议！</li><li class="listitem" style="list-style-type: disc">Twitter等社交网络每秒处理数百万用户创建和共享的大量数据。为了让他们的系统一直保持运行，他们对可以使用他们的API挖掘的数据量进行了限制(尽管安全性也是这些限制背后的一个主要原因)。这些限制使数据科学工作陷入困境，因为很难获得足够的数据样本来正确/完整地代表总体。样本不足可能导致不正确的模式或完全错过模式。</li><li class="listitem" style="list-style-type: disc">结果的预处理和评估也是社交网络分析的一个挑战。在对数据进行预处理时，我们去除了噪声内容。随着数据以各种形状和大小出现，确定有噪声的内容比简单地删除停用词更具挑战性。对结果的评估是另一个挑战，因为在大多数情况下没有地面实况，并且由于这里和其他地方提出的限制，很难有把握地确定结果的有效性。</li></ul></div><p>上面提出的论点/挑战要求数据科学家设计出创新和创造性的方法，这使得他们的工作有趣且回报丰厚。</p></div></body></html>
<html><head><title>References</title><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>

<meta content="urn:uuid:cbb088e0-b938-4095-bde0-7154a8c2646b" name="Adept.expected.resource"/></head><body id="page"><div><div><div><div><h1 class="title"><a id="ch07lvl1sec58"/>参考文献</h1></div></div></div><p>一些关于可视化的知名<a class="indexterm" id="id560"/>书籍如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.amazon.in/Information-Dashboard-Design-At-Glance/dp/1938377001">http://www . Amazon . in/Information-Dashboard-Design-At-Glance/DP/1938377001</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.amazon.com/Visual-Display-Quantitative-Information/dp/096139210X">http://www . Amazon . com/Visual-Display-Quantitative-Information/DP/096139210 x</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.amazon.com/Information-Visualization-Second-Interactive-Technologies/dp/1558608192">http://www . Amazon . com/Information-Visualization-Second-Interactive-Technologies/DP/1558608192</a></li></ul></div><p>一些著名的博客<a class="indexterm" id="id561"/>如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>画面</strong> <a class="indexterm" id="id562"/> <strong>具体</strong>:<a class="ulink" href="http://www.jewelloree.com/">http://www.jewelloree.com/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://flowingdata.com/">http://flowingdata.com/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.informationisbeautiful.net/">http://www.informationisbeautiful.net/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://infosthetics.com/">http://infosthetics.com/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.visualisingdata.com/">http://www.visualisingdata.com/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://eagereyes.org/">https://eagereyes.org/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://thedailyviz.com/">http://thedailyviz.com/</a></li><li class="listitem" style="list-style-type: disc"><strong>D3</strong>:<a class="indexterm" id="id563"/>T31】https://d3js.org/</li></ul></div></div></body></html>
<html><head><title>Summary</title><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>

<meta content="urn:uuid:cbb088e0-b938-4095-bde0-7154a8c2646b" name="Adept.expected.resource"/></head><body id="page"><div><div><div><div><h1 class="title"><a id="ch07lvl1sec59"/>总结</h1></div></div></div><p>社会网络分析是数据科学领域的热门话题之一。正如我们在本章中所看到的，这些平台不仅为我们提供了联系的方式，也为我们提供了在全球范围内研究人类动态的独特机会。通过这一章，我们学到了一些有趣的技巧。我们从理解社交网络环境中的数据挖掘开始，接着是可视化的重要性。我们专注于Twitter，理解不同的对象和API来操纵它们。我们使用来自R的各种包，比如<code class="literal">TwitteR</code>和<code class="literal">TM</code>，来连接、收集和操作数据，以便进行分析。我们使用Twitter上的数据来了解整个过程中的频率。最后，我们介绍了社交网络词汇和联想、tweeple使用的流行设备、层次聚类以及话题建模带来的一些挑战。我们使用<code class="literal">ggplot2</code>和<code class="literal">wordcloud</code>将我们的结果可视化到一般的数据挖掘过程中。在结束这一章的时候，我们确信现在你可以欣赏这些平台背后惊人的动态和R分析这一切的能力。我们还没有结束<code class="literal">@Twitter</code>，抓紧你的<code class="literal">#sentiments</code>！</p></div></body></html></body></html>