<html><head/><body>



<title>Chapter 3. A Simple Machine Learning Analysis</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch03"/>第三章。一个简单的机器学习分析</h1></div></div></div><p>本章展示了探索性数据分析和机器学习技术的例子。r为我们提供了不同的数据集，可以用来试验这些工具。在这一章中，我们将使用一个关于泰坦尼克号乘客的有趣数据集。</p><p>泰坦尼克号事件期间发生的一些事实，比如先救妇孺的政策，第一社会阶层的特权。为了调查发生了什么，我们可以使用与事件相关的数据。R数据集是关于一些乘客的，它显示了他们的个人数据和幸存者。首先，我们可以探索一些数据，以了解发生了什么。然后，从其他乘客的个人数据出发，机器学习模型的目标是预测哪些新乘客将幸存下来。</p><p>在本章中，我们将讨论以下主题:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">探索数据</li><li class="listitem" style="list-style-type: disc">使用简单的图表可视化数据</li><li class="listitem" style="list-style-type: disc">使用机器学习技术探索数据</li><li class="listitem" style="list-style-type: disc">使用机器学习技术预测结果</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>交互浏览数据</h1></div></div></div><p>本节<a id="id117" class="indexterm"/>向您展示如何使用简单的技术来可视化数据。我们使用<code class="literal">data.table</code>包处理数据，并使用基本的R图可视化信息。一个很棒的绘图包是<code class="literal">ggplot2</code>，它允许你创建漂亮的专业图表。不幸的是，它的语法比基本的R图表更复杂，所以我们在本书中没有足够的篇幅来介绍它。</p><p>r为我们提供了一个<code class="literal">Titanic</code>数据集，其中包含了一些乘客的生存统计数据。在开始分析数据之前，让我们用下面的代码看一下他们的文档:</p><div><pre class="programlisting">help(Titanic)</pre></div><p>文件显示，乘客是根据他们的社会阶层、性别和年龄分组的。对于每一组，数据集显示了有多少人幸存，有多少人没有。我们可以使用<code class="literal">class</code>来查看数据的格式:</p><div><pre class="programlisting">class(Titanic)
<strong>[1] "table"</strong>
</pre></div><p>对象<code class="literal">Titanic</code>属于<code class="literal">table</code>类，因此它显示<a id="id118" class="indexterm"/>类变量的每个组合的计数，如下所示:</p><div><pre class="programlisting">Titanic
<strong>, , Age = Child, Survived = No</strong>

<strong>      Sex</strong>
<strong>Class  Male Female</strong>
<strong>  1st     0      0</strong>
<strong>  2nd     0      0</strong>
<strong>  3rd    35     17</strong>
<strong>  Crew    0      0</strong>
<strong>...</strong>
</pre></div><p>该表显示了频率，即每个变量组合的乘客人数，这些变量是个人数据和幸存者的数据。</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>用数据定义表格</h2></div></div></div><p>在这一<a id="id119" class="indexterm"/>小节中，我们将以更方便的<a id="id120" class="indexterm"/>格式转换数据。第一步是定义数据框:</p><div><pre class="programlisting">dfTitanic &lt;- data.frame(Titanic)</pre></div><p>我们可以用<code class="literal">str</code>看到<code class="literal">dfTitanic</code>的结构:</p><div><pre class="programlisting">str(dfTitanic)
<strong>'data.frame':   32 obs. of  5 variables:</strong>
<strong> $ Class   : Factor w/ 4 levels "1st","2nd","3rd",..: 1 2 3 4 1 2 3 4 1 2 ...</strong>
<strong> $ Sex     : Factor w/ 2 levels "Male","Female": 1 1 1 1 2 2 2 2 1 1 ...</strong>
<strong> $ Age     : Factor w/ 2 levels "Child","Adult": 1 1 1 1 1 1 1 1 2 2 ...</strong>
<strong> $ Survived: Factor w/ 2 levels "No","Yes": 1 1 1 1 1 1 1 1 1 1 ...</strong>
<strong> $ Freq    : num  0 0 35 0 0 0 17 0 118 154 ...</strong>
</pre></div><p>有四个因素代表乘客的属性，<code class="literal">Freq</code>显示每个属性组合的乘客数量。为了使用强大的工具处理数据，我们将<code class="literal">dfTitanic</code>转换成数据表:</p><div><pre class="programlisting">library(data.table)
dtTitanic &lt;- data.table(dfTitanic)</pre></div><p>我们可以使用<code class="literal">head</code>来可视化表格的顶行:</p><div><pre class="programlisting">head(dtTitanic)
<strong>   Class    Sex   Age Survived Freq</strong>
<strong>1:   1st   Male Child       No    0</strong>
<strong>2:   2nd   Male Child       No    0</strong>
<strong>3:   3rd   Male Child       No   35</strong>
<strong>4:  Crew   Male Child       No    0</strong>
<strong>5:   1st Female Child       No    0</strong>
<strong>6:   2nd Female Child       No    0</strong>
</pre></div><p>这里，<code class="literal">Class</code>、<code class="literal">Sex</code>、<code class="literal">Age</code>和<code class="literal">Survived</code>代表属性，<code class="literal">Freq</code>显示每个组合的乘客数量。例如，有35名三等男生幸存下来。其他五个特征组合没有乘客。</p><p>为了开始<a id="id121" class="indexterm"/>分析，我们可以定义包含<a id="id122" class="indexterm"/>乘客总数的<code class="literal">nTot</code>:</p><div><pre class="programlisting">nTot &lt;- dtTitanic[, sum(Freq)]
nTot
<strong>[1] 2201</strong>
</pre></div><p>还有<code class="literal">2201</code>乘客。他们之中，有多少人幸存？我们可以使用一个简单的数据表聚合来计算幸存和未幸存的乘客。我们需要指定以下内容:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>操作</strong>:在<a id="id123" class="indexterm"/>统计乘客的顺序中，我们对<code class="literal">Freq</code>列求和，所以操作为<code class="literal">n=sum(Freq)</code></li><li class="listitem" style="list-style-type: disc"><strong>聚合</strong>:我们<a id="id124" class="indexterm"/>为<code class="literal">Survived</code>列的每个可能值计算乘客数量，因此我们需要指定我们通过<code class="literal">Survived</code>进行聚合</li></ul></div><p>这是数据表语法。我们使用方括号和三个参数:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>要选择的行</strong>:我们正在使用所有的表，所以参数为空</li><li class="listitem" style="list-style-type: disc"><strong>操作</strong>:包含一个包含该操作的列表，即<code class="literal">n=sum(Freq)</code></li><li class="listitem" style="list-style-type: disc"><strong>聚合</strong>:我们指定聚合<code class="literal">by='Survived'</code></li></ul></div><p>考虑以下代码:</p><div><pre class="programlisting">dtSurvived &lt;- dtTitanic[, list(n=sum(Freq)), by='Survived']
dtSurvived
<strong>   Survived    n</strong>
<strong>1:       No 1490</strong>
<strong>2:      Yes  711</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>通过直方图可视化数据</h2></div></div></div><p>我们可以通过构建直方图<a id="id127" class="indexterm"/>来<a id="id126" class="indexterm"/>可视化<code class="literal">dtSurvived</code>，R函数为<code class="literal">barplot</code>:</p><div><pre class="programlisting">help(barplot)</pre></div><p>在我们的例子中，我们需要的参数是<code class="literal">height</code>和<code class="literal">names.arg</code>，指定条形的高度和标签。在我们的例子中，两个参数都需要一个向量。让我们看看如何构建图表。请遵循以下步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">用包含乘客人数的高度定义向量:<div> <pre class="programlisting">vectorHeight &lt;- dtSurvived[, n]</pre> </div></li><li class="listitem">用包含幸存乘客人数的名字定义向量:<div> <pre class="programlisting">vectorNames &lt;- dtSurvived[, Survived]</pre> </div></li><li class="listitem">构建图表:<div> <pre class="programlisting">barplot(height=vectorHeight, names.arg=vectorNames)</pre> </div></li></ol></div><p>直方图如下所示:</p><div><img src="img/7740OS_03_01.jpg" alt="Visualizing the data through a histogram"/></div><p>直方图显示了幸存或未幸存的乘客人数。每个条形的高度等于乘客的数量，标签显示条形所代表的内容。我们可以只用一行代码构建相同的图表:</p><div><pre class="programlisting">barplot(height=dtSurvived[, n], names.arg=dtSurvived[, Survived])</pre></div><p>这张图表显示了乘客总数。如果我们想把百分比可视化呢？让我们来看看以下步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">定义包含乘客数量除以总乘客数量的<code class="literal">percentage</code>列。我们可以使用<code class="literal">:=</code>数据表操作来定义新列。此列将是<code class="literal">height</code>自变量:<div> <pre class="programlisting">dtSurvived[, percentage := n / sum(n)]</pre> </div></li><li class="listitem">为可视化定义包含蓝色和红色的<code class="literal">colorPlot</code>列。我们使用<code class="literal">ifelse</code>，这是一个函数，如果<code class="literal">Survived == 'Yes'</code>指定颜色为<code class="literal">blue</code>，否则为<code class="literal">red</code>。该列将是<code class="literal">col</code>自变量:<div> <pre class="programlisting">dtSurvived[, colorPlot := ifelse(Survived == 'Yes', 'blue', 'red')]</pre> </div></li><li class="listitem">构建图表，正如预期的那样，我们包括了<code class="literal">col</code>参数，定义了<code class="literal">color</code>向量。此外，百分比的范围在0和1之间，因此我们可以通过添加等于<code class="literal">c(0, 1)</code> : <div> <pre class="programlisting">barplot(   height=dtSurvived[, percentage],   names.arg=dtSurvived[, Survived],   col=dtSurvived[, colorPlot],   ylim=c(0, 1) )</pre> </div>的<code class="literal">ylim</code>参数来指定绘图的面积将在0和1之间</li></ol></div><p><a id="id130" class="indexterm"/>直方图如下:</p><div><img src="img/7740OS_03_02.jpg" alt="Visualizing the data through a histogram"/></div><p>我们可以为图表添加标题和图例；请遵循以下步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">将包含百分比的<code class="literal">textPercentage</code>列定义为字符串。例如，对于百分比0.323035，我们在图例中显示32%:<div><pre class="programlisting">dtSurvived[, textPercentage := paste(round(percentage * 100), '%', sep='')]</pre></div></li><li class="listitem">定义<a id="id132" class="indexterm"/>剧情标题:<div> <pre class="programlisting">plotTitle &lt;- 'Proportion of passengers surviving or not'</pre> </div></li><li class="listitem">定义<a id="id133" class="indexterm"/><em/>y轴标签:<div> <pre class="programlisting">ylabel &lt;- 'percentage'</pre> </div></li><li class="listitem">构建剧情:<div> <pre class="programlisting">barplot(   height=dtSurvived[, percentage],   names.arg=dtSurvived[, Survived],   col=dtSurvived[, colorPlot],   ylim=c(0, 1),   legend.text=dtSurvived[, textPercentage],   ylab=ylabel,   main=plotTitle )</pre> </div></li></ol></div><p>直方图如下所示:</p><div><img src="img/7740OS_03_03.jpg" alt="Visualizing the data through a histogram"/></div><p>一般的<a id="id134" class="indexterm"/>存活率是<strong> 32% </strong>，虽然在<a id="id135" class="indexterm"/>不同的属性组合上有所不同。下一小节将向您展示如何可视化属性的影响。</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>可视化特征的影响</h2></div></div></div><p>在这个<a id="id136" class="indexterm"/>小节中，我们确定了性别对存活率的影响。首先，我们可以定义<code class="literal">dtGender</code>显示每个性别幸存或未幸存的乘客数量。该操作为<code class="literal">n=sum(Freq)</code>，针对<code class="literal">Survived</code>和<code class="literal">Sex</code>的每一个组合进行。与上一节类似，我们执行一个简单的数据表聚合，指定以下内容:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>要选择的行</strong>:我们正在使用整个表，所以参数为空</li><li class="listitem" style="list-style-type: disc"><strong>操作</strong>:包含操作的列表，即<code class="literal">n=sum(Freq)</code></li><li class="listitem" style="list-style-type: disc"><strong>聚合</strong>:我们按两列聚合，所以我们定义<code class="literal">by=c('Survived', 'Sex')</code></li></ul></div><p>考虑以下代码:</p><div><pre class="programlisting">dtGender &lt;- dtTitanic[, list(n=sum(Freq)), by=c('Survived', 'Sex')]
dtGender
<strong>   Survived    Sex    n</strong>
<strong>1:       No   Male 1364</strong>
<strong>2:       No Female  126</strong>
<strong>3:      Yes   Male  367</strong>
<strong>4:      Yes Female  344</strong>
</pre></div><p>现在，我们可以<a id="id137" class="indexterm"/>通过直方图来可视化新的数据表，就像我们之前看到的那样。步骤如下:</p><div><ol class="orderedlist arabic"><li class="listitem">添加<code class="literal">percentage</code>栏，将<code class="literal">n</code>除以该性别的乘客人数。操作是<code class="literal">n / sum(n)</code>，按性别来做。然后，我们使用<code class="literal">:=</code>操作，指定我们计算总和<code class="literal">by='Sex'</code> : <div> <pre class="programlisting">dtGender[, percentage := n / sum(n), by='Sex']</pre> </div></li><li class="listitem">定义绘图颜色:<div> <pre class="programlisting">dtGender[, colorPlot := ifelse(Survived == 'Yes', 'blue', 'red')]</pre> </div></li><li class="listitem">定义<em> y </em>轴标签:<div> <pre class="programlisting">dtGender[, textPercentage := paste(round(percentage * 100), '%', sep='')]</pre> </div></li><li class="listitem">提取表格中的男性生存统计:<div> <pre class="programlisting">dtGenderMale &lt;- dtGender[Sex == 'Male']</pre> </div></li><li class="listitem">建立男性直方图:<div> <pre class="programlisting">barplot(   height=dtGenderMale[, percentage],   names.arg=dtGenderMale[, Survived],   col=dtGenderMale[, colorPlot],   ylim=c(0, 1),   legend.text=dtGenderMale[, textPercentage],   ylab='percentage',   main='Survival rate for the males' )</pre> </div></li><li class="listitem">我们可以不提取<code class="literal">dtGenderMale</code>，而是直接构建图表，在提取向量时添加<code class="literal">Sex == 'Male'</code>。我们可以用类似的方法为女性建立相同的直方图:<div> <pre class="programlisting">barplot(   height=dtGender[Sex == 'Female', percentage],   names.arg=dtGender[Sex == 'Female', Survived],   col=dtGender[Sex == 'Female', colorPlot],   ylim=c(0, 1),   legend.text=dtGender[Sex == 'Female', textPercentage],   ylab='percentage',   main='Survival rate for the females' )</pre> </div></li></ol></div><p>让我们展示一下我们制作的图表:</p><div><img src="img/7740OS_03_04.jpg" alt="Visualizing the impact of a feature"/></div><p>与幸存乘客的32%相比，男性的存活率仅为21%。</p><div><img src="img/7740OS_03_05.jpg" alt="Visualizing the impact of a feature"/></div><p>不出所料，女性存活率明显高于平均水平。</p><p>我们可以在同一个图表中比较两种性别，该图表显示的是存活率，即<code class="literal">Yes</code>栏。我们可以使用相同的命令并包括<code class="literal">Survived == 'Yes'</code>条件来构建情节。唯一的区别是<code class="literal">col</code>参数，在本例中是<code class="literal">Sex</code>列，它是一个具有两个级别的因子。在这种情况下，<code class="literal">barplot</code>自动定义黑色和红色两种<a id="id139" class="indexterm"/>颜色:</p><div><pre class="programlisting">barplot(
  height=dtGender[Survived == 'Yes', percentage],
  names.arg=dtGender[Survived == 'Yes', Sex],
  col=dtGender[Survived == 'Yes', Sex],
  ylim=c(0, 1),
  legend.text=dtGender[Survived == 'Yes', textPercentage],
  ylab='percentage',
  main='Survival rate by gender'
)</pre></div><p>直方图如下所示:</p><div><img src="img/7740OS_03_06.jpg" alt="Visualizing the impact of a feature"/></div><p>图表让我们可以看到差异，图例显示存活率。不出所料，差别是巨大的。</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>将两个特征的影响可视化</h2></div></div></div><p>在这<a id="id141" class="indexterm"/>一章中，我们研究另一个特性的影响:阶级。不同等级的乘客存活率有什么不同？首先，我们可以按照以下步骤构建与性别相同的存活率图表:</p><div><ol class="orderedlist arabic"><li class="listitem">定义<code class="literal">dtClass</code>包含每个等级幸存或未幸存的乘客:<div> <pre class="programlisting">dtClass &lt;- dtTitanic[, list(n=sum(Freq)), by=c('Survived', 'Class')]</pre> </div></li><li class="listitem">定义每个等级幸存或未幸存乘客的百分比:<div> <pre class="programlisting">dtClass[, percentage := n / sum(n), by='Class']</pre> </div></li><li class="listitem">定义百分比文本:<div> <pre class="programlisting">dtClass[, textPercentage := paste(round(percentage * 100), '%', sep='')]</pre> </div></li><li class="listitem">构建直方图:<div> <pre class="programlisting">barplot(   height=dtClass[Survived == 'Yes', percentage],   names.arg=dtClass[Survived == 'Yes', Class],   col=dtClass[Survived == 'Yes', Class],   ylim=c(0, 1),   legend.text=dtClass[Survived == 'Yes', textPercentage],   ylab='survival rate',   main='Survival rate by class' )</pre> </div></li></ol></div><p><a id="id142" class="indexterm"/>直方图如下:</p><div><img src="img/7740OS_03_07.jpg" alt="Visualizing the impact of two features combined"/></div><p>各个班级的存活率差异很大。我们可以注意到，属于较高等级的乘客更有可能存活，并且机组人员的存活率与第三等级相似。能否得出阶级对存活率影响大的结论？</p><p>图表显示了每个班级的总存活率。然而，知道了女性更有可能存活，一个具有更高的女性:男性比率的班级将有可能有更高的存活率。如果仅仅用性别来解释较高的存活率，那么属于不同阶层的事实根本没有影响。</p><p>为了了解存活率之间的差异是否取决于每个班级中雌性的百分比，我们可以按班级将性别比例可视化。该图是一个直方图，显示了每个社会阶层的女性百分比，命令与前面的命令相似:</p><div><pre class="programlisting">dtGenderFreq &lt;- dtTitanic[, list(n=sum(Freq)), by=c('Sex', 'Class')]
dtGenderFreq[, percentage := n / sum(n), by='Class']
dtGenderFreq &lt;- dtGenderFreq[Sex == 'Female']
dtGenderFreq[, textPercentage := paste(round(percentage * 100), '%', sep='')]
barplot(
  height=dtGenderFreq[, percentage],
  names.arg=dtGenderFreq[, Class],
  col=dtGenderFreq[, Class],
  ylim=c(0, 1),
  legend.text=dtGenderFreq[, textPercentage],
  ylab='survival rate',
  main='Percentage of females'
)</pre></div><p>直方图如下所示:</p><div><img src="img/7740OS_03_08.jpg" alt="Visualizing the impact of two features combined"/></div><p>不同班级的性别比例差异很大，因为女性在顶级班级中的比例更高，而且船员中几乎没有女性。因此，女性的百分比可能会使各个阶层的存活率有所偏差。为了更好地理解这两个属性对存活率的影响，我们需要同时考虑<a id="id144" class="indexterm"/>性别和阶级。为此，我们可以计算这两个特征的每个组合的存活率。使用以下步骤构建图表:</p><div><ol class="orderedlist arabic"><li class="listitem">计算<code class="literal">Survived</code>、<code class="literal">Sex</code>和<code class="literal">Class</code>每种组合的乘客总数。现在<code class="literal">by</code>参数包括三个列名:<div> <pre class="programlisting">dtGenderClass &lt;- dtTitanic[, list(n=sum(Freq)), by=c('Survived', 'Sex', 'Class')]</pre> </div></li><li class="listitem">添加<code class="literal">nTot</code>列，指定每个特征组合的乘客总数(不包括<code class="literal">Survived</code>)。<code class="literal">by</code>论据包括两个特点:<div> <pre class="programlisting">dtGenderClass[, nTot := sum(n), by=c('Sex', 'Class')]</pre> </div></li><li class="listitem">添加<code class="literal">percentage</code>列。<code class="literal">by</code>参数包括两个特性:<div> <pre class="programlisting">dtGenderClass[, percentage := n / sum(n), by=c('Sex', 'Class')]</pre> </div></li><li class="listitem">使用<code class="literal">Survived == 'Yes'</code>条件提取包含存活率的列:<div> <pre class="programlisting">dtGenderClass &lt;- dtGenderClass[Survived == 'Yes']</pre> </div></li><li class="listitem">添加<code class="literal">textPercentage</code>栏:<div> <pre class="programlisting">dtGenderClass[, textPercentage := paste(round(percentage * 100), '%', sep='')]</pre> </div></li><li class="listitem">增加<code class="literal">colorPlot</code>栏。<code class="literal">rainbow</code>函数用定义数量的彩虹颜色构建一个向量。在这种情况下，我们为每一行定义一列，所以我们使用<code class="literal">rainbow(nrow(dtGenderClass))</code> : <div> <pre class="programlisting">dtGenderClass[, colorPlot := rainbow(nrow(dtGenderClass))]</pre> </div></li><li class="listitem">定义要包含在标签中的组名。由于直方图将显示两种特征的每种组合的存活率，我们使用<code class="literal">paste</code>将每个组的名称设置为性别和类别的组合。为了将这些名字放入图表中，我们定义了包含性别缩写的<code class="literal">SexAbbr</code>:<div><pre class="programlisting">dtGenderClass[, SexAbbr := ifelse(Sex == 'Male', 'M', 'F')] dtGenderClass[, barName := paste(Class, SexAbbr, sep='')]</pre></div></li><li class="listitem">定义<a id="id145" class="indexterm"/>标签，包含地块名称和组内乘客数量。因为我们想在两个不同的行中显示名字和号码，我们用<code class="literal">\n</code>将它们分开，它在一个字符串中定义了一个新行:<div> <pre class="programlisting">dtGenderClass[, barLabel := paste(barName, nTot, sep='\n')]</pre> </div></li><li class="listitem">生成直方图。与<code class="literal">ylim</code>类似，<code class="literal">xlim</code>参数定义了要可视化的<em> x </em>区域。在这种情况下，我们使用<code class="literal">xlim</code>来避免图例和图表重叠:<div> <pre class="programlisting">barplot(   height=dtGenderClass[, percentage],   names.arg=dtGenderClass[, barLabel],   col=dtGenderClass[, colorPlot],   xlim=c(0, 11),   ylim=c(0, 1),   ylab='survival rate',   legend.text=dtGenderClass[, textPercentage] )</pre> </div></li></ol></div><p>生成的直方图如下:</p><div><img src="img/7740OS_03_09.jpg" alt="Visualizing the impact of two features combined"/></div><p>我们可以在一个小组的栏目下找到该小组的乘客人数。除了女乘务员，每个酒吧至少有100名乘客，所以我们可以假设这个结果是有意义的。为了衡量意义，我们可以使用统计技术，如<a id="id146" class="indexterm"/>置信区间或假设检验，但这不是本书的主题。</p><p>这个阶层以不同的方式影响着男性和女性。就男性而言，存活率很低，尽管第一班的存活率明显较高。就女生而言，除了三年级以外，每个班级的存活率接近100%。</p><p>我们也可以反过来看这张图表，以了解性别对同等级乘客的影响。在所有情况下，存活率都明显较高，尽管某些特定类别的差异要高得多。性别和阶级的影响是相关的，所以如果我们想了解它们的影响，我们需要同时考虑这两个特征。</p><p>我们还没有探索年龄。我们可以想象所有特征的每种组合的存活率。准备和绘制表格的代码与前面类似。在这种情况下，我们可以直接对<code class="literal">dtTitanic</code>进行操作。步骤如下:</p><div><ol class="orderedlist arabic"><li class="listitem">计算这三个特征的每种组合的存活或死亡人数的百分比:<div> <pre class="programlisting">dtTitanic[, nTot := sum(Freq), by=c('Sex', 'Class', 'Age')]</pre> </div></li><li class="listitem">添加每个属性组合的幸存乘客百分比:<div> <pre class="programlisting">dtTitanic[, percentage := Freq / nTot]</pre> </div></li><li class="listitem">使用<code class="literal">Survived == 'Yes'</code>条件提取存活率:<div> <pre class="programlisting">dtAll &lt;- dtTitanic[Survived == 'Yes', ]</pre> </div></li><li class="listitem">添加图例文本，包括所有三个特征的缩写。对于类，我们使用substring，它是一个提取字符串一部分的函数。在我们的例子中，我们<a id="id147" class="indexterm"/>提取第一个字符，所以我们指定使用<code class="literal">substring(Class, 1, 1)</code> : <div> <pre class="programlisting">dtAll[, ClassAbbr := substring(Class, 1, 1)] dtAll[, SexAbbr := ifelse(Sex == 'Male', 'M', 'F')] dtAll[, AgeAbbr := ifelse(Age == 'Child', 'C', 'A')] dtAll[, textLegend := paste(ClassAbbr, SexAbbr, AgeAbbr, sep='')];</pre> </div>提取<code class="literal">1</code>和<code class="literal">1</code>之间的元素</li><li class="listitem">添加地块颜色:<div> <pre class="programlisting">dtAll[, colorPlot := rainbow(nrow(dtAll))]</pre> </div></li><li class="listitem">添加要在标签中显示的百分比:<div> <pre class="programlisting">dtAll[, labelPerc := paste(round(percentage * 100), '%', sep='')]</pre> </div></li><li class="listitem">添加包括百分比和总数的标签:<div> <pre class="programlisting">dtAll[, label := paste(labelPerc, nTot, sep='\n')]</pre> </div></li><li class="listitem">生成情节。我们有比以前更多的组，所以布局是不同的，以便可视化所有相关信息。<code class="literal">xlim</code>参数为图例留出一些空间，<code class="literal">cex.names</code>参数减小标签文本大小:<div> <pre class="programlisting">barplot(   height=dtAll[, percentage],   names.arg=dtAll[, label],   col=dtAll[, colorPlot],   xlim=c(0, 23),   legend.text=dtAll[, textLegend],   cex.names=0.5 )</pre> </div></li></ol></div><p>直方图如下所示:</p><div><img src="img/7740OS_03_10.jpg" alt="Visualizing the impact of two features combined"/></div><p>图例显示缩写的功能组合。例如，<strong> 1MC </strong>表示头等舱，男性，儿童。在没有乘客的组合情况下，我们没有关于百分比的任何信息，所以条形标签显示<strong> NaN% </strong>。</p><p>因为我们结合了三个特征，所以一些组非常小。例如，我们只有五个一年级男生。也有其他完全没有乘客的群体(比如机组人员中的孩子)。因此，这种方法有一定的局限性。</p></div></div></div>





<title>Exploring the data using machine learning models</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>使用机器学习模型探索数据</h1></div></div></div><p>可视化每组乘客的<a id="id149" class="indexterm"/>存活率为我们提供了一个数据概览。我们知道<a id="id150" class="indexterm"/>不同的特征是如何与存活率相互影响的。例如，我们知道社会阶层对存活率的影响因性别而异。但是这两个特性哪个影响最大呢？每个特性的影响有多大？我们还没有定义这些特性的等级，也没有量化每个特性的影响。一些机器学习技术允许我们进一步调查，回答我们的问题。</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>使用决策树探索数据</h2></div></div></div><p>我们有三个特征(阶级、性别和年龄),我们想相应地将乘客分组。我们无法为每个<a id="id152" class="indexterm"/>特征组合定义一个组，因为我们没有足够的数据用于某些组，比如第一个班级的女生。一种解决方案是将乘客分组，每组包含足够的数据。群体由特征上的一些条件来定义，例如不属于第一类的雄性。这些小组应该涵盖每一种可能的情况，不要重叠。一种识别足够大的组的机器学习技术是决策树学习。</p><p>有一位新乘客，我们知道他是二等舱的一个男孩。我们不知道乘客能否生还，我们想预测一下。我们如何使用这些数据？我们可以检查乘客是男是女。因此，根据我们之前的数据探索，他有21%的概率活下来，因为他是男性。考虑到社会阶层，我们可以说他活下来的概率是14%。有179名二等男乘客，所以这个结果是有意义的。那么，知道他是一个孩子，我们就可以查一下二等男孩子的存活率，是百分之百。说他有百分之百的概率活下来有意义吗？只有11名乘客是二等舱的男性儿童，所以我们没有足够的数据来做出准确的预测。应该用二等男的存活率吗？如果我们用所有男孩的存活率来代替呢？二班的孩子呢？不同的选择会导致不同的结果。</p><p>一个解决方案是识别关键特征并只考虑它们。例如，如果性别和阶级是两个最重要的特征，我们可以用它们来做预测。然而，在第三类男孩的情况下，我们比第一类男孩有更多的数据。如果我们只考虑三等男性的年龄呢？我们希望包含的功能数量取决于我们考虑的群体。</p><p>除了选择两个最重要的特征之外，我们可以定义一个标准来划分一个足够大的组，并且我们可以通过决策树来可视化这个原则。让我们假设开始时所有的乘客都属于同一个组。我们可以根据性别把他们分成两组。然后，我们可以将男性分成两组:一边是第一类，另一边是所有其他类。对雌性来说，最有意义的分裂可能是另一种:一边是孩子，另一边是成年人。</p><p>决策树学习技术从数据中学习，以便识别最有意义的拆分，并且可以用于探索数据。树继续分割数据，直到由树叶定义的组太小。然后，对于每个组，我们使用相关数据来定义一个属性，该属性可以是:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> Categoric </strong>:这是一个<a id="id153" class="indexterm"/>属性，其值属于类别。在这种情况下，类别为<strong>幸存</strong>和<strong>未幸存</strong>。该树执行分类。</li><li class="listitem" style="list-style-type: disc"><strong>数字</strong>:这是<a id="id154" class="indexterm"/>一个可以衡量的属性，在这里是存活率。该树执行回归。</li></ul></div><p>我们可以使用<code class="literal">rpart</code>包在R中构建一个决策树。此外，我们可以使用另一个包<code class="literal">rpart.plot</code>来可视化这些树。为了使用这些包，我们需要安装并加载它们。如果出现安装问题，您可以将存储库指定为<code class="literal">install.packages</code>的一个参数:</p><div><pre class="programlisting">install.packages('rpart')
install.packages('rpart.plot')</pre></div><p>安装完成后，我们可以加载两个包:</p><div><pre class="programlisting">library('rpart')
library('rpart.plot')</pre></div><p>起点是<code class="literal">dtTitanic</code>,它为每个特征组合包含一行。在构建决策树之前，我们需要将数据转换成另一种格式。我们需要<a id="id155" class="indexterm"/>为每个乘客安排一行，并且<a id="id156" class="indexterm"/>除了<code class="literal">Freq</code>之外还有相同的列。为了生成新格式的新表格，我们用<code class="literal">list</code>和<code class="literal">by</code>进行数据表操作。</p><p>对于<code class="literal">dtTitanic</code>的每一行，我们希望生成一个行数等于<code class="literal">Freq</code>的表。每一行对应于<code class="literal">Survived</code>、<code class="literal">Sex</code>、<code class="literal">Age</code>和<code class="literal">Class</code>之间的组合，因此<code class="literal">by</code>参数包含一个具有四个特征的向量。</p><p>在新表中，每一行包含一名乘客，因此<code class="literal">Freq</code>等于<code class="literal">1</code>。然后，对于<code class="literal">dtTitanic</code>的每一行，我们需要定义一个具有等于<code class="literal">1</code>的<code class="literal">Freq</code>元素的向量。为了做到这一点，我们使用<code class="literal">rep</code>,它是一个函数，将一个元素复制规定的次数。在我们的例子中，我们使用<code class="literal">rep(1, Freq))</code>。其他列复制了在<code class="literal">by</code>中定义的元素，即<code class="literal">Survived</code>、<code class="literal">Sex</code>、<code class="literal">Age</code>和<code class="literal">Class</code>，因此我们不需要重新定义它们:</p><div><pre class="programlisting">dtLong &lt;- dtTitanic[
  , list(Freq = rep(1, Freq)),
  by=c('Survived', 'Sex', 'Age', 'Class')
  ]</pre></div><p><code class="literal">Freq</code>是每行的<code class="literal">1</code>，所以我们不再需要它，可以删除它:</p><div><pre class="programlisting">dtLong[, Freq := NULL]</pre></div><p>为了构建一个显示存活率的决策树，我们需要改变<code class="literal">Survived</code>的格式。不是有<code class="literal">No</code>和<code class="literal">Yes</code>，而是分别要<code class="literal">0</code>和<code class="literal">1</code>。要修改该列，我们可以使用<code class="literal">ifelse</code>:</p><div><pre class="programlisting">dtLong[, Survived := ifelse(Survived == 'Yes', 1, 0)]</pre></div><p>用<code class="literal">head</code>来看看<code class="literal">DtLong</code>的前六排:</p><div><pre class="programlisting">head(dtLong)
<strong>   Survived  Sex   Age Class</strong>
<strong>1:        0 Male Child   3rd</strong>
<strong>2:        0 Male Child   3rd</strong>
<strong>3:        0 Male Child   3rd</strong>
<strong>4:        0 Male Child   3rd</strong>
<strong>5:        0 Male Child   3rd</strong>
<strong>6:        0 Male Child   3rd</strong>
</pre></div><p>前六排显示了六个没有存活下来的男孩。</p><p><code class="literal">dtLong</code>对象<a id="id157" class="indexterm"/>包含决策树算法的标准输入，我们可以使用<code class="literal">rpart</code>来构建模型。我们的目标是定义我们能够估计存活率的乘客群体:</p><div><pre class="programlisting">help(rpart)</pre></div><p>强制的<a id="id158" class="indexterm"/>参数有:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">formula</code>:这是一个公式对象，定义要预测的属性和用于预测的特征。公式由字符串定义，如<code class="literal">outcome ~ feature1 + feature2 + feature3</code>。</li><li class="listitem" style="list-style-type: disc"><code class="literal">data</code>:这是数据帧或数据表，在我们的例子中是<code class="literal">dtLong</code>。</li></ul></div><p>我们需要从<code class="literal">Survived ~ Sex + Age + Class</code>字符串开始定义<a id="id159" class="indexterm"/>公式:</p><div><pre class="programlisting">formulaRpart &lt;- formula('Survived ~ Sex + Age + Class')</pre></div><p>现在我们可以构建包含决策树的<code class="literal">treeRegr</code>。由于<code class="literal">Survived</code>是数字，该函数自动构建一个<code class="literal">regrssion</code>树:</p><div><pre class="programlisting">treeRegr &lt;- rpart(
  formula=formulaRpart,
  data=dtLong
)</pre></div><p><code class="literal">treeRegr</code>对象包含决策树，我们可以使用<code class="literal">prp(treeRegr)</code>来可视化它:</p><div><img src="img/7740OS_03_11.jpg" alt="Exploring the data using a decision tree"/></div><p>让我们看看这棵树。每个内部节点都标有将数据分成两部分的条件。例如，顶部的节点将乘客分为男性和女性。左边的分支对应于满足条件的乘客(在本例中是男性乘客)，右边的分支对应于其他乘客(女性)。每片叶子决定了群体的存活率。例如，右边的叶子表明不属于第三类的雌性的存活率是93%。</p><p>由于缺乏数据，该树没有<a id="id160" class="indexterm"/>包含所有可能的特征组合。例如，在雌性的例子中，只有45个孩子，他们属于不同的社会阶层，所以树没有根据年龄划分雌性。</p><p>让我们假设我们有一个新的乘客是女性，儿童，二等舱。我们如何预测她能否幸存？她是不属于第三类的女性，所以她的预期存活率是93%。因此，我们可以说她将有可能活下来。</p><p>这个树定义了一个存活率，它是一个数字。如果我们想预测乘客是否幸存呢？我们可以建立一个分类树，将<code class="literal">method='class'</code>输入添加到<code class="literal">rpart</code>:</p><div><pre class="programlisting">treeClass = rpart(
    formula='Survived ~ Sex + Age + Class',
    data=dtLong,
    method='class'
)
prp(treeClass)</pre></div><p>树形图<a id="id162" class="indexterm"/>如下所示:</p><div><img src="img/7740OS_03_12.jpg" alt="Exploring the data using a decision tree"/></div><p>这棵树预言，幸存的乘客只有不属于第三等级的女性和儿童。这个结果对探索数据是有用的。下一步是使用机器学习模型来预测结果。我们可以使用这个树来达到这个目的，尽管它<a id="id163" class="indexterm"/>只定义了16种可能的特征组合中的五组乘客，所以它可能不是最合适的<a id="id164" class="indexterm"/>技术。还有更高级的算法，在下一章我们将看到其中的一种。</p></div></div>





<title>Predicting newer outcomes</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">预测更新的结果</h1></div></div></div><p>给定一名新的<a id="id165" class="indexterm"/>乘客，并知道他或她的个人信息，我们希望预测他或她是否会幸存。到目前为止，我们探索的选择是基于将乘客分组并确定每组的存活率。对于一些特征的组合，例如第一类女性儿童，我们没有足够的数据，所以我们必须使用更大群体的存活率，例如不属于第三类的女性。我们忽略了一些细节，例如，他们是孩子的事实，这样我们就失去了信息。不管我们有多少乘客，有没有一种方法可以估计任何特征组合的存活率？</p><p>有许多<a id="id166" class="indexterm"/>机器学习算法会同时考虑所有特征。在这一章中，我们看到了一个非常流行的算法，那就是<strong>随机森林</strong>算法。在这种情况下，这并不是最好的选择，因为当有更多的特性时，它的性能会更好，但是对于说明一种通用方法来说，这是很好的。</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>建立机器学习模型</h2></div></div></div><p>顾名思义，随机森林算法基于许多随机决策树。该算法重复以下步骤构建<code class="literal">ntree</code>树:</p><div><ol class="orderedlist arabic"><li class="listitem">从sampsize倍的数据(在我们的例子中，即<code class="literal">dtLong</code>)中选择一个随机行来生成构建树的数据。每一行都可以选择多次，最后我们得到一个sampsize随机行的表。</li><li class="listitem">随机选择一个<code class="literal">mtry</code>数量的特征(不幸的是，在我们的例子中，我们没有很多特征，但仍然有可能选择其中的一个子集)。</li><li class="listitem">仅考虑所选特征，基于采样数据构建决策树。</li></ol></div><p>一个随机森林模型由<code class="literal">ntree</code>决策树组成。在我们的上下文中，给定一个新乘客，模型使用每棵树来预测他们的存活率。最终的预测值是存活率之间的平均值。在算法的另一个变体中，我们用众数代替平均值。</p><p>随机森林是一种流行的算法，由<code class="literal">randomForest</code>包提供。让我们安装并加载它:</p><div><pre class="programlisting">install.packages('randomForest')
library('randomForest')</pre></div><p>像简单的决策树学习一样，随机森林属性可以是分类的或数字的。</p><p>在我们的例子中，所有的特征都是分类的，每个特征有两到四个可能的值。我们可以将特征转换成数字格式。例如，在<code class="literal">Sex</code>的情况下，可能的值是<code class="literal">Male</code>和<code class="literal">Female</code>。我们可以定义一个数字特征，在<code class="literal">Male</code>的情况下为<code class="literal">1</code>，否则为<code class="literal">0</code>。新功能以不同的方式显示相同的信息。以这种方式从范畴中导出的数字特征称为哑变量。如果一个类别特征有两个以上的类别，我们可以为每个类别定义一个虚拟变量。这样看哑变量，如果其中一个等于<code class="literal">1</code>，就知道是哪些组了。如果都等于<code class="literal">0</code>，我们就知道还剩一组。</p><p>我们可以通过以下步骤定义一个包含虚拟变量的<a id="id168" class="indexterm"/>新表:</p><div><ol class="orderedlist arabic"><li class="listitem">建立类别特征表的副本:<div> <pre class="programlisting">dtDummy &lt;- copy(dtLong)</pre> </div></li><li class="listitem">将<code class="literal">Sex</code>转换成虚拟变量:<div> <pre class="programlisting">dtDummy[, Male := Sex == 'Male'] dtDummy[, Sex := NULL]</pre> </div></li><li class="listitem">将<code class="literal">Age</code>转换成虚拟变量:<div> <pre class="programlisting">dtDummy[, Child := Age == 'Child'] dtDummy[, Age := NULL]</pre> </div></li><li class="listitem">将<code class="literal">Class</code>转换成三个虚拟变量:<div> <pre class="programlisting">dtDummy[, Class1 := Class == '1st'] dtDummy[, Class2 := Class == '2nd'] dtDummy[, Class3 := Class == '3rd'] dtDummy[, Class := NULL]</pre> </div></li><li class="listitem">定义<code class="literal">formulaRf</code>公式:<div> <pre class="programlisting">formulaRf &lt;- formula('Survived ~ Male + Child + Class1 + Class2 + Class3')</pre> </div></li><li class="listitem">构建包含随机森林模型的<code class="literal">forest</code>。所有参数都保留默认值:<div> <pre class="programlisting">forest &lt;- randomForest(   formula=formulaRf,   data=dtDummy )</pre> </div></li></ol></div><p>我们将随机森林模型存储在<code class="literal">forest</code>中，这是一个包含机器学习模型以及所有相关参数和信息的列表。我们可以通过观察列表中的元素来探索这个模型。例如，模型构建的树的数量包含在<code class="literal">ntree</code>元素中:</p><div><pre class="programlisting">forest$ntree
<strong>[1] 500</strong>
</pre></div><p>另一个参数是<code class="literal">mtry</code>，它定义了每次迭代中使用的变量数量:</p><div><pre class="programlisting">forest$mtry
<strong>[1] 1</strong>
</pre></div><p>树的数量默认为500。</p><p>该算法一次只选择一个特征。原因是随机森林旨在与许多功能一起工作，因此它在这种情况下性能不佳。</p><p>另一个参数是<code class="literal">type</code>，它定义了算法的输出。随机森林可用于不同的目的，在我们的例子中，我们希望估计存活率，因此我们希望将其用于回归:</p><div><pre class="programlisting">forest$type
<strong>[1] "regression"</strong>
</pre></div><p>正如所料，<code class="literal">forest</code>正在执行回归。</p><p>如果我们想<a id="id169" class="indexterm"/>改变一些参数，我们可以在自变量中定义它们。在这一章中，我们没有定义一个标准来设置参数，所以我们只是分配另一个值。例如，我们可以使用三个随机特征和每个随机特征的<code class="literal">1500</code>随机行来构建<code class="literal">1000</code>树。我们可以通过改变参数来重建<code class="literal">forest</code>:</p><div><pre class="programlisting">forest &lt;- randomForest(
  formula=formulaRf,
  data=dtDummy,
  ntree=1000,
  mtry=3,
  sampsize=1500
)</pre></div><p>我们构建了一个随机的<code class="literal">forest</code>模型，下一小节将展示如何使用它。</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>使用模型预测新的结果</h2></div></div></div><p>现在<a id="id170" class="indexterm"/>我们已经建立了模型，我们可以用它来<a id="id171" class="indexterm"/>执行一些预测。如果我们有一个新乘客，他们的存活率是多少？首先，让我们随机抽取一名乘客:</p><div><pre class="programlisting">rowRandom &lt;- dtDummy[100]
rowRandom
<strong>   Survived Freq Male Child Class1 Class2 Class3</strong>
<strong>1:       No    1 TRUE FALSE   TRUE  FALSE  FALSE</strong>
</pre></div><p>随机乘客是头等舱的一名成年男性。我们可以用<code class="literal">forest</code>模型来估计他的存活率。<code class="literal">predict</code>函数允许我们对新数据应用模型，获得预测:</p><div><pre class="programlisting">predict(forest, rowRandom)
<strong>        1 </strong>
<strong>0.3830159</strong>
</pre></div><p>估计存活率约为38 %,所以乘客不太可能生还。我们可以用同样的方法来预测所有乘客的存活率。然而，这意味着将模型应用于我们用来构建它的相同数据。这种方法不适合测试模型，因为预测值将与初始数据相关。请记住，这个结果不能使用，我们可以使用它来比较预测和真实数据:</p><div><pre class="programlisting">prediction = predict(forest, dtDummy)</pre></div><p>我们可以看到使用<code class="literal">sample</code>对六个随机行的预测:</p><div><pre class="programlisting">sample(prediction, 6)
<strong>     1895       448       967      1553      1683         4 </strong>
<strong>0.6934046 0.2260507 0.2499303 0.3830159 0.2260507 0.2974706</strong>
</pre></div><p>我们定义了每位乘客的存活率。让我们将估计的存活率添加到<code class="literal">dtDummy</code>表中:</p><div><pre class="programlisting">dtDummy[, SurvivalRatePred := predict(forest, dtDummy)]</pre></div><p>现在，我们可以预测，如果一名乘客的存活率高于某个阈值，例如50 %,他将会活下来。我们可以定义一个<a id="id173" class="indexterm"/>新列名<code class="literal">SurvivedPred</code>，包含我们的预测:</p><div><pre class="programlisting">dtDummy[, SurvivedPred := ifelse(SurvivalRatePred &gt; 0.5, 1, 0)]</pre></div><p>现在我们可以将预测的存活率与初始数据进行比较。为了评估这两个值匹配的次数，我们可以定义一个<code class="literal">error</code>列，如果这两个值不匹配，它就是<code class="literal">TRUE</code>:</p><div><pre class="programlisting">dtDummy[, error := SurvivedPred != Survived]</pre></div><p>从误差栏开始，我们可以将总误差计算为我们做出错误预测的乘客的百分比。我们需要用错误的数量除以乘客的数量。由于布尔变量向量的和等于<code class="literal">TRUE</code>值的数量，所以我们可以将和应用于错误的错误数量。乘客总数由<code class="literal">.N</code>定义，在<code class="literal">data.table</code>符号中等于行数:</p><div><pre class="programlisting">percError &lt;- dtDummy[, sum(error) / .N]
percError
<strong>[1] 0.2094502</strong>
</pre></div><p>该模型在21%的情况下预测了错误的结果，因此我们的准确率为79%。无论如何，这个结果没有任何意义，因为我们是在我们用来建立模型的相同数据上进行预测的。此外，知道了有多少乘客幸存，我们就可以猜测出他们每个人最常见的结局。如果有超过一半的人幸存，我们可以为所有人设置<code class="literal">SurvivedPred = TRUE</code>，猜测超过一半。让我们计算一下幸存的总概率。总的存活率低于50 %,所以每位乘客更有可能无法生还。然后，在没有任何其他信息的情况下，我们可以预测无人生还:</p><div><pre class="programlisting">dtTitanic[Survived == 'No', sum(Freq)] / dtTitanic[, sum(Freq)]
<strong>[1] 0.676965</strong>
</pre></div><p>在不考虑任何特征的情况下，我们可以让<a id="id174" class="indexterm"/>达到超过65%的准确率，所以79%只高出15%。此外，如前所述，这种准确性无法使用，因为我们将模型应用于构建它所用的相同数据。</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>验证模型</h2></div></div></div><p>为了评估一个模型的真实准确性，我们可以使用一部分数据来构建它，比如80%的乘客。然后，我们可以对剩下的20%的数据应用该模型。我们用来建立模型的数据称为<a id="id177" class="indexterm"/> <strong>训练集</strong> <a id="id178" class="indexterm"/>，另一个称为<strong>测试集</strong>。</p><p>我们可以以80%的概率将每一行分配给训练集。这样，训练集将包含大约80%的数据。为了定义哪些行应该包括在训练集中<a id="id179" class="indexterm"/>，我们可以定义一个逻辑向量，称为<code class="literal">indexTrain</code>，它是属于训练集的每一行的<code class="literal">TRUE</code>。我们可以使用sample生成向量，参数如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>:这代表可能的值；在这种情况下，<code class="literal">TRUE</code>和<code class="literal">FALSE</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">size</code>:表示向量长度；在这种情况下，它等于<code class="literal">dtDummy</code>中的行数</li><li class="listitem" style="list-style-type: disc"><code class="literal">replace</code>:如果数值为<code class="literal">TRUE</code>，每个数值(<code class="literal">TRUE</code>或<code class="literal">FALSE</code>)可以采样多次</li><li class="listitem" style="list-style-type: disc"><code class="literal">prob</code>:这是一个向量，具有对<code class="literal">x</code>的值进行采样的概率；在这种情况下，它是<code class="literal">c(0.8, 0.2)</code></li></ul></div><p>考虑以下代码:</p><div><pre class="programlisting">indexTrain &lt;- sample(
  x=c(TRUE, FALSE),
  size=nrow(dtDummy),
  replace=TRUE,
  prob=c(0.8, 0.2)
)</pre></div><p>现在，我们可以提取<code class="literal">indexTrain</code>等于<code class="literal">TRUE</code>的行:</p><div><pre class="programlisting">dtTrain &lt;- dtDummy[indexTrain]</pre></div><p>同样，我们提取测试集的行。<code class="literal">!</code>运算符是指<code class="literal">NOT</code>，它允许提取<code class="literal">indexTrain</code>等于<code class="literal">FALSE</code>的行；</p><div><pre class="programlisting">dtTest &lt;- dtDummy[!indexTrain]</pre></div><p>现在，我们可以使用与之前相同的参数来构建模型。知道我们有更少的数据，我们可以减少定义用于每棵树的数据的sampsize参数:</p><div><pre class="programlisting">forest &lt;- randomForest(
  formula=formulaRf,
  data=dtTrain,
  ntree=1000,
  mtry=3,
  sampsize=1200
)</pre></div><p>我们建立了一个模型<a id="id180" class="indexterm"/>，没有考虑<code class="literal">dtTest</code>，所以我们可以用它来预测<code class="literal">dtTest</code>。像以前一样，我们预测如果一名乘客的存活率高于50 %,他将会活下来。预测之后，我们可以使用与之前相同的R命令来估计误差:</p><div><pre class="programlisting">dtTest[, SurvivalRatePred := predict(forest, dtTest)]
dtTest[, SurvivedPred := ifelse(SurvivalRatePred &gt; 0.5, 1, 0)]
dtTest[, error := SurvivedPred != Survived]
percError &lt;- dtTest[, sum(error) / .N]
percError
<strong>[1] 0.2416107</strong>
</pre></div><p>估计误差<code class="literal">percError</code>取决于我们如何分割数据，因此每次我们定义新的随机训练/测试分割时，它都是不同的。然而，我们可以多次重复这些步骤，并计算平均误差。这种方法被称为交叉验证，它是一种非常有用的评估准确性的工具。</p><p>本章展示了构建和验证机器学习模型的一般方法。使用这种方法，我们可以预测一个属性并估计预测的准确性。</p></div></div>





<title>Summary</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>总结</h1></div></div></div><p>在本章中，我们学习了如何使用数据表操作处理数据，并构建了一些简单的R图用于探索性数据分析。我们学习了如何使用决策树来找到有用的见解，并建立机器学习模型(随机森林)来执行预测。我们看到了如何更改模型的参数以及如何验证它。</p><p>接下来的三章详细介绍了本章中介绍的步骤。<a class="link" href="ch04.html" title="Chapter 4. Step 1 – Data Exploration and Feature Engineering">第4章</a>、<em>步骤1——数据探索和特征工程</em>，深入展示了由数据探索和特征工程组成的机器学习的第一步。</p></div>
</body></html>