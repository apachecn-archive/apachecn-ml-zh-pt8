<html><head/><body>



<title>Chapter 8. Machine Learning Examples Applicable to Businesses</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch08"/>第八章。适用于企业的机器学习示例</h1></div></div></div><p>本章的目的是向你展示机器学习如何帮助解决一个商业问题。大部分技巧在前一章已经探讨过了，所以这一章的节奏很快。这些技术是关于无监督和有监督的学习。无监督算法从数据中提取隐藏结构，监督技术预测属性。本章使用属于这两个分支的技术解决了一个业务挑战。</p><p>在本章中，您将学习如何:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">将机器学习方法应用于商业问题</li><li class="listitem" style="list-style-type: disc">细分银行的客户群</li><li class="listitem" style="list-style-type: disc">确定营销活动的目标</li><li class="listitem" style="list-style-type: disc">选择表现更好的技术</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec43"/>问题概述</h1></div></div></div><p>一家葡萄牙银行机构发起电话营销活动。机构资源有限，需要选择目标客户。从关于过去活动的数据开始，我们可以使用机器学习技术为公司提供一些支持。这些数据显示了客户的个人信息和以前营销活动的信息。机器学习算法的目标是识别更有可能订阅的客户。从数据出发，算法需要理解如何使用新客户的数据来预测他们每个人订阅的可能性。</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec45"/>数据概述</h2></div></div></div><p>数据<a id="id419" class="indexterm"/>包括大约2，500多名客户，他们受到一次或多次电话营销活动的影响。我们有一些关于客户的细节，我们知道谁订阅了。</p><p>表中的每一行对应于一个客户端，如果客户端订阅了，则有一列显示输出为<code class="literal">yes</code>，否则为<code class="literal">no</code>。其他列是描述客户端的功能，它们是:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>个人信息</strong>:包括年龄、工作、婚姻状况、教育程度、信用违约、年平均余额、住房、个人贷款等信息</li><li class="listitem" style="list-style-type: disc"><strong>与公司的沟通</strong>:包括联络类型、上次联络月份和工作日、上次通话时长、联络次数等详细信息</li><li class="listitem" style="list-style-type: disc"><strong>之前的活动</strong>:包括之前活动的天数、过去的联系次数和过去的结果等详细信息</li></ul></div><p>这是这张桌子的样品。<code class="literal">y</code>列显示属性，如果客户端订阅，则预测<code class="literal">yes</code>，否则预测<code class="literal">no</code>。</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>年龄</p>
</th><th style="text-align: left" valign="bottom">
<p>职位</p>
</th><th style="text-align: left" valign="bottom">
<p>婚姻状况</p>
</th><th style="text-align: left" valign="bottom">
<p>...</p>
</th><th style="text-align: left" valign="bottom">
<p>接触</p>
</th><th style="text-align: left" valign="bottom">
<p>…</p>
</th><th style="text-align: left" valign="bottom">
<p>y</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>30</p>
</td><td style="text-align: left" valign="top">
<p>服务</p>
</td><td style="text-align: left" valign="top">
<p>已婚的</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>细胞的</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>不</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>33</p>
</td><td style="text-align: left" valign="top">
<p>管理</p>
</td><td style="text-align: left" valign="top">
<p>单一的</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>电话</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>是</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>41</p>
</td><td style="text-align: left" valign="top">
<p>体力劳动者的</p>
</td><td style="text-align: left" valign="top">
<p>单一的</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>未知的</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>不</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>35</p>
</td><td style="text-align: left" valign="top">
<p>自己经营的</p>
</td><td style="text-align: left" valign="top">
<p>已婚的</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>电话</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>不</p>
</td></tr></tbody></table></div><p>数据存储在<code class="literal">bank.csv</code>中，我们可以将它们加载到R中，构建一个数据表。<code class="literal">sep=';'</code>字段指定文件中的字段用分号分隔，如下所示:</p><div><pre class="programlisting">library(data.table)
dtBank &lt;- data.table(read.csv('bank.csv', sep=';'))</pre></div><p><code class="literal">duration</code>功能显示最后一次通话的秒数。我们分析的目标是确定给哪些客户打电话，在联系客户之前我们无法知道持续时间。此外，在知道一个呼叫持续时间之后，我们已经知道客户端是否订阅了，所以使用这个属性来预测结果是没有意义的。出于这些原因，我们移除了<code class="literal">duration</code>功能，如下所示:</p><div><pre class="programlisting"># remove the duration
dtBank[, duration := NULL]</pre></div><p>下一步是<a id="id420" class="indexterm"/>探索数据，以了解背景。</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec46"/>探索输出</h2></div></div></div><p>在这个<a id="id421" class="indexterm"/>小节中，我们快速浏览和转换数据。</p><p><code class="literal">y</code>输出是分类的，可能的结果是<code class="literal">yes</code>和<code class="literal">no</code>，我们的目标是可视化比例。为此，我们可以使用以下步骤构建一个饼图:</p><div><ol class="orderedlist arabic"><li class="listitem">使用<code class="literal">table</code> : <div> <pre class="programlisting">dtBank[, table(y)] <strong>y</strong> <strong>  no  yes</strong> <strong>4000  521</strong> </pre> </div>统计有多少客户订阅，有多少没有订阅</li><li class="listitem">确定客户端订阅和不订阅的百分比:<div> <pre class="programlisting">dtBank[, table(y) / .N] <strong>y</strong> <strong>     no     yes </strong> <strong>0.88476 0.11524</strong> </pre> </div></li><li class="listitem">构建一个从比例开始确定百分比的函数:<div> <pre class="programlisting">DefPercentage &lt;- function(frequency) {   percentage = frequency / sum(frequency)   percentage = round(percentage * 100)   percentage = paste(percentage, '%')   return(percentage) }</pre> </div></li><li class="listitem">确定百分比:<div> <pre class="programlisting">defPercentage(dtBank[, table(y) / .N]) <strong>[1] "88 %" "12 %"</strong> </pre> </div></li><li class="listitem">看<code class="literal">barplot</code>的帮助那就是R函数构建条形图:<div> <pre class="programlisting">help(barplot)</pre> </div></li><li class="listitem">定义柱状图输入:<div> <pre class="programlisting">tableOutput &lt;- dtBank[, table(y)] colPlot &lt;- rainbow(length(tableOutput)) percOutput &lt;- defPercentage(tableOutput)</pre> </div></li><li class="listitem">构建柱状图:<div> <pre class="programlisting">barplot(   height = tableOutput,   names.arg = percOutput,   col = colPlot,   legend.text = names(tableOutput),   xlab = 'Subscribing'   ylab = 'Number of clients',   main = 'Proportion of clients subscribing' )</pre> </div></li></ol></div><p>得到的<a id="id422" class="indexterm"/>图如下:</p><div><img src="img/7740OS_08_01.jpg" alt="Exploring the output"/></div><p>只有12%的客户端订阅，所以输出值不是平均分布的。下一步是探索所有的数据。</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec47"/>探索和转换功能</h2></div></div></div><p>类似于<a id="id423" class="indexterm"/>输出，我们可以构建一些图表来探究这些特性。让我们先用<code class="literal">str</code>来看看它们:</p><div><pre class="programlisting">str(dtBank)
Classes 'data.table' and 'data.frame':    4521 obs. of  16 variables:
<strong> $ age      : int  30 33 35 30 59 35 36 39 41 43 ...</strong>
<strong> $ job      : Factor w/ 12 levels "admin.","blue-collar",..: 11 8 5 5 2 5 7 10 3 8 ...</strong>
<strong> $ marital  : Factor w/ 3 levels "divorced","married",..: 2 2 3 2 2 3 2 2 2 2 ...</strong>
<strong>...</strong>
</pre></div><p>这些要素属于两种数据类型:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>类别</strong>:该<a id="id425" class="indexterm"/>数据类型以因子格式存储特征</li><li class="listitem" style="list-style-type: disc"><strong>数字</strong>:该<a id="id426" class="indexterm"/>数据类型以整数格式存储特征</li></ul></div><p>分类特性的图表不同于数字特性的图表，因此我们需要将特性分成两组。通过使用以下步骤，我们可以定义一个包含类别特征的向量和另一个用于数字特征的向量:</p><div><ol class="orderedlist arabic"><li class="listitem">使用<code class="literal">lapply</code> : <div> <pre class="programlisting">classFeatures &lt;- lapply(dtBank, class)</pre> </div>定义每个<a id="id427" class="indexterm"/>列类</li><li class="listitem">删除包含输出的<code class="literal">y</code>列:<div> <pre class="programlisting">classFeatures &lt;- classFeatures[names(classFeatures) != 'y']</pre> </div></li><li class="listitem">确定类别特征:<div> <pre class="programlisting">featCategoric &lt;- names(classFeatures)[   classFeatures == 'factor'   ]</pre> </div></li><li class="listitem">确定数字特征:<div> <pre class="programlisting">featNumeric &lt;- names(classFeatures)[   classFeatures == 'integer'   ]</pre> </div></li></ol></div><p>与输出类似，我们可以为九个类别特征中的每一个构建一个饼图。为了避免有<a id="id428" class="indexterm"/>太多的图表，我们可以在同一个图表中放三个馅饼。R函数是<code class="literal">par</code>，它允许定义图表网格:</p><div><pre class="programlisting">help(par)</pre></div><p>我们需要的输入是:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mfcol</code>:这是一个包含列数和行数的<a id="id429" class="indexterm"/>向量。对于每个特性，我们用饼图和图例分别构建一个图表。我们把饼图放在最下面一行，图例放在最上面。然后，我们有两行和三列。</li><li class="listitem" style="list-style-type: disc"><code class="literal">mar</code>:这是一个定义绘图页边空白的<a id="id430" class="indexterm"/>矢量:<div> <pre class="programlisting">par(mfcol = c(2, 3), mar = c(3, 4, 1, 2))</pre> </div></li></ul></div><p>现在，我们可以使用一个<code class="literal">for</code>循环来构建直方图:</p><div><pre class="programlisting">for(feature in featCategoric){</pre></div><p>在<code class="literal">for</code>循环中执行以下步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">定义饼状图输入:<div> <pre class="programlisting">  TableFeature &lt;- dtBank[, table(get(feature))]   rainbCol &lt;- rainbow(length(tableFeature))   percFeature &lt;- defPercentage(tableFeature)</pre> </div></li><li class="listitem">定义一个新的<a id="id431" class="indexterm"/>图，其图例由与其颜色匹配的特征名称组成。我们添加特征名作为图例标题:<div> <pre class="programlisting">   plot.new()    legend(      'top', names(tableFeature),      col = rainbCol, pch = 16,      title = feature    )</pre> </div></li><li class="listitem">构建<a id="id432" class="indexterm"/>直方图，该直方图将显示在底部一行:<div> <pre class="programlisting">  barplot(     height = tableFeature,     names.arg = percFeature,     col = colPlot,     xlab = feature,     ylab = 'Number of clients'   ) }</pre> </div></li></ol></div><p>我们构建了三个图表，每个图表包含三个类别特征。让我们来看看第一个:</p><div><img src="img/7740OS_08_02.jpg" alt="Exploring and transforming features"/></div><p><code class="literal">job</code>属性有不同的级别，其中一些有大量的客户端。然后，我们可以为每个相关作业定义一个虚拟变量，忽略其他变量。为了确定最相关的工作，我们确定属于每个级别的人的百分比。然后，我们设置一个阈值，忽略百分比低于阈值的所有级别<a id="id434" class="indexterm"/>。在这种情况下，阈值为0.08，即8%。定义新的虚拟列后，我们删除<code class="literal">job</code>:</p><div><pre class="programlisting">percJob &lt;- dtBank[, table(job) / .N]
colRelevant &lt;- names(percJob)[percJob &gt; 0.08]
for(nameCol in colRelevant){
  newCol &lt;- paste('job', nameCol, sep='_')
  dtBank[, eval(newCol) := ifelse(job == nameCol, 1, 0)]
}
dtBank[, job := NULL]</pre></div><p>在这里，<code class="literal">marital</code>定义了婚姻状况，有三个等级，其中<code class="literal">divorced</code>和<code class="literal">single</code>有一个较小但重要的部分。我们可以定义两个虚拟变量来定义三个级别:</p><div><pre class="programlisting">dtBank[, single := ifelse(marital == 'single', 1, 0)]
dtBank[, divorced := ifelse(marital == 'divorced', 1, 0)]
dtBank[, marital := NULL]</pre></div><p>关于<code class="literal">education</code>，超过一半的客户接受过中等教育，所以我们可以假设<a id="id435" class="indexterm"/>4%的<code class="literal">unknown</code>是<code class="literal">secondary</code>。然后，我们有三个属性，我们可以定义两个虚拟变量:</p><div><pre class="programlisting">dtBank[, edu_primary := ifelse(education == 'primary', 1, 0)]
dtBank[, edu_tertiary := ifelse(education == 'tertiary', 1, 0)]
dtBank[, education := NULL]</pre></div><p>得到的<a id="id436" class="indexterm"/>剧情如下:</p><div><img src="img/7740OS_08_03.jpg" alt="Exploring and transforming features"/></div><p><strong>默认</strong>、<strong>住房</strong>、<strong>贷款</strong>属性有两个不同的级别，因此可以使用<code class="literal">as.numeric</code>将<a id="id437" class="indexterm"/>转换成数字形式。为了在属性<a id="id438" class="indexterm"/>为<code class="literal">no</code>时得到<code class="literal">0</code>，在属性为<code class="literal">yes</code>时得到<code class="literal">1</code>，我们减去<code class="literal">1</code>，如下<a id="id439" class="indexterm"/>:</p><div><pre class="programlisting">dtBank[, housing := as.numeric(housing) - 1]
dtBank[, default := as.numeric(default) - 1]
dtBank[, loan := as.numeric(loan) - 1]</pre></div><p>获得的直方图如下:</p><div><img src="img/7740OS_08_04.jpg" alt="Exploring and transforming features"/></div><p>这里，<strong>联系</strong> <a id="id440" class="indexterm"/>有三个选项，其中一个是<strong>未知</strong>。所有选项都有一个有效部分，因此我们可以定义两个虚拟变量，如下所示:</p><div><pre class="programlisting">dtBank[, cellular := ifelse(contact == 'cellular', 1, 0)]
dtBank[, telephone := ifelse(contact == 'telephone', 1, 0)]
dtBank[, contact := NULL]</pre></div><p>我们可以将<code class="literal">month</code>转换成一个数字变量，其中一月对应于<code class="literal">1</code>，十二月对应于<code class="literal">12</code>。<a id="id441" class="indexterm"/>特征值是没有大写字母缩写的月份名称，例如<code class="literal">jan</code>代表<code class="literal">January</code>。为了定义数字特征，我们<a id="id442" class="indexterm"/>定义了一个向量，它的第一个元素是<code class="literal">jan</code>，第二个元素是<code class="literal">feb</code>，依此类推。然后，使用<code class="literal">which</code>，我们可以识别向量的相应元素。例如，<code class="literal">apr</code>是向量的第四个元素，所以使用<code class="literal">which</code>我们得到<code class="literal">4</code>。为了构建带有有序月份名称的向量，我们使用包含缩写月份名称的<code class="literal">month.abb</code>和不大写第一个字母的<code class="literal">tolower</code>，如下所示:</p><div><pre class="programlisting">Months &lt;- tolower(month.abb)
months &lt;- c(
    'jan', 'feb', 'mar', 'apr', 'may', 'jun',
    'jul', 'aug', 'sep', 'oct', 'nov', 'dec'
)
dtBank[
  , month := which(month == months),
  by=1:nrow(dtBank)
  ]</pre></div><p>在<code class="literal">poutcome</code>、<code class="literal">success</code>和<code class="literal">failure</code>有一小部分客户。但是，它们非常相关，因此我们定义了两个虚拟变量:</p><div><pre class="programlisting">dtBank[, past_success := ifelse(poutcome == 'success', 1, 0)]
dtBank[, past_failure := ifelse(poutcome == 'failure', 1, 0)]
dtBank[, poutcome := NULL]</pre></div><p>我们将所有的分类特征转换成数字格式。下一步是研究数字特征，并在必要时对它们进行转换。</p><p>有六个数字特征，我们可以为每个特征建立一个图表。该图表是一个直方图，显示了特征值的分布情况。为了可视化同一图表中的所有数字，我们可以使用<code class="literal">par</code>将它们放入一个3 x 2的网格中。论据如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mfrow</code>:与<code class="literal">mfcol</code>类似，定义一个图形网格。区别只是我们将数字添加到网格中的顺序。</li><li class="listitem" style="list-style-type: disc"><code class="literal">mar</code>:我们将页边距设置为其默认值，即<code class="literal">c(5, 4, 4, 2) + 0.1</code>，如下:<div> <pre class="programlisting">par(mfrow=c(3, 2), mar=c(5, 4, 4, 2) + 0.1)</pre> </div></li></ul></div><p>我们可以使用<code class="literal">hist</code>构建<a id="id443" class="indexterm"/>直方图。输入如下所示:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>:这是带有数据的向量</li><li class="listitem" style="list-style-type: disc"><code class="literal">main</code>:这是剧情标题</li><li class="listitem" style="list-style-type: disc"><code class="literal">xlab</code>:这是x轴下的标签</li></ul></div><p>我们可以在数据表里面直接使用<code class="literal">hist</code>和<a id="id444" class="indexterm"/>方括号。为了一步完成所有的图表，我们使用了一个<code class="literal">for</code>循环:</p><div><pre class="programlisting">for(feature in featNumeric){
  dtBank[, hist(x = get(feature), main=feature, xlab = feature)]
}</pre></div><p>获得的直方图如下:</p><div><img src="img/7740OS_08_05.jpg" alt="Exploring and transforming features"/></div><p>这里，<strong>年龄</strong>和<strong>日</strong>均匀分布在它们的可能值上，所以它们不需要任何处理。剩下的特性都集中在小值上，所以我们需要对它们进行变换。我们用来定义变换特征的函数是对数，它<a id="id445" class="indexterm"/>允许我们有更多的扩展值。对数适用于值大于0的要素，因此我们需要从要素中移除负值。</p><p>为了避免零，在计算对数之前，将<code class="literal">1</code>加到特征上。</p><p>根据数据描述，如果机构之前没有联系过客户<a id="id446" class="indexterm"/>，则<code class="literal">pdays</code>等于<code class="literal">-1</code>。为了识别第一次联系的客户，如果<code class="literal">pdays</code>等于<code class="literal">-1</code>，我们可以定义一个新的虚拟变量<code class="literal">1</code>。然后，我们用<code class="literal">0</code>替换所有负值，如下:</p><div><pre class="programlisting">dtBank[, not_contacted := ifelse(pdays == -1, 1, 0)]
dtBank[pdays == -1, pdays := 0]</pre></div><p><code class="literal">balance</code>特性代表过去的余额，如果余额为负，我们可以定义一个虚拟变量<code class="literal">1</code>。然后，我们用<code class="literal">0</code>替换负余额:</p><div><pre class="programlisting">dtBank[, balance_negative := ifelse(balance &lt; 0, 1, 0)]
dtBank[balance &lt; 0, balance := 0]</pre></div><p>现在，我们可以计算所有特征的对数。由于对数的输入必须是正的，并且一些特征等于<code class="literal">0</code>，我们在计算对数之前将<code class="literal">1</code>加到每个特征上:</p><div><pre class="programlisting">dtBank[, pdays := log(pdays + 1)]
dtBank[, balance := log(balance + 1)]
dtBank[, campaign := log(campaign + 1)]
dtBank[, previous := log(previous + 1)]</pre></div><p>我们已经将所有特征转换成数字格式。现在，我们可以看看新功能表:</p><div><pre class="programlisting">str(dtBank)
View(dtBank)</pre></div><p>唯一不是数字或整数的列<a id="id447" class="indexterm"/>是输出<code class="literal">y</code>。我们可以将其转换为数字格式，并将其名称改为output:</p><div><pre class="programlisting">dtBank[, output := as.numeric(y) – 1]
dtBank[, y := NULL]</pre></div><p>我们加载并清理了数据。现在我们已经准备好建立机器学习模型了。</p></div></div></div>





<title>Clustering the clients</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch08lvl1sec44"/>聚集客户</h1></div></div></div><p>为了应对下一次营销活动，我们需要确定更有可能订阅的客户。由于很难逐一评估客户，我们可以确定同类客户群，并确定最有希望的客户群。</p><p>从过去的数据开始，我们根据客户的个人信息对他们进行分类。然后，给定一个新的<a id="id450" class="indexterm"/>客户端，我们识别最相似的组，并将这个新客户端关联到它。我们没有关于新客户的客户行为的信息，所以聚类仅仅基于个人属性。</p><p>执行聚类有不同的技术，在本节中，我们使用一种相关的算法，即分层聚类。层次聚类的一个参数是链接，这是计算两个组之间距离的方法。主要选项有:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>单联动</strong>:该<a id="id451" class="indexterm"/>是第一组物体和第二组物体之间的最小距离</li><li class="listitem" style="list-style-type: disc"><strong>完全联动</strong>:这是第一组物体和第二组物体之间的<a id="id452" class="indexterm"/>最大距离</li><li class="listitem" style="list-style-type: disc"><strong>平均链接</strong>:这个<a id="id453" class="indexterm"/>是第一组物体和第二组物体之间的平均距离</li></ul></div><p>在我们的例子中，我们选择平均链接，这个选择来自于对三个选项的测试。</p><p>我们将仅包含个人特征的<code class="literal">dtPers</code>定义如下:</p><div><pre class="programlisting">featPers &lt;- c(
  'age', 'default', 'balance', 'balance_negative',
  'housing', 'loan',
  'job_admin.', 'job_blue-collar',	'job_management',
  'job_services', 'job_technician',
  'single', 'divorced', 'edu_primary', 'edu_tertiary'
)
dtPers &lt;- dtBank[, featPers, with=F]</pre></div><p>现在，我们可以应用层次聚类，步骤如下:</p><div><ol class="orderedlist arabic"><li class="listitem">定义相异度矩阵:<div> <pre class="programlisting">d &lt;- dist(dtPers, method = 'euclidean')</pre> </div></li><li class="listitem">构建层次聚类模型:<div> <pre class="programlisting">hcOut &lt;- hclust(d, method = 'average')</pre> </div></li><li class="listitem">想象树状图。<code class="literal">par</code>方法定义了绘图布局，在这种情况下,<a id="id454" class="indexterm"/>只包含一个图表,<code class="literal">plot</code>包含一个改善外观的参数。<code class="literal">labels</code>和<code class="literal">hang</code>特性避免在底部出现<a id="id455" class="indexterm"/>混乱的图表，其他参数指定绘图标题和轴标签，如下所示:<div> <pre class="programlisting">par(mfrow = c(1, 1)) plot(   hcOut,   labels = FALSE,   hang = -1,   main = 'Dendrogram',   xlab = 'Client clusters',   ylab = 'Agglomeration distance' )</pre> </div></li></ol></div><p>获得的直方图如下:</p><div><img src="img/7740OS_08_06.jpg" alt="Clustering the clients"/></div><p>我们可以识别出围绕<strong> 40 </strong>高度切割树状图的三个集群。还有另一个选项是<a id="id456" class="indexterm"/>在较低的级别(大约18)切割树状图，识别七个集群。我们可以探索这两个选项，并使用<code class="literal">rect.hclust</code>在树状图上可视化两个<a id="id457" class="indexterm"/>分裂，如下所示:</p><div><pre class="programlisting">k1 &lt;- 3
k2 &lt;- 7
par(mfrow=c(1, 1))
rect.hclust(hcOut, k = k1)
rect.hclust(hcOut, k = k2)</pre></div><p>获得的直方图如下:</p><div><img src="img/7740OS_08_07.jpg" alt="Clustering the clients"/></div><p>为了识别最成功的集群，我们可以使用饼图显示订阅的客户端比例，并将集群中的客户端数量作为其标题。让我们看看第一次分裂的三个集群的图表。构建饼图的步骤类似于我们之前执行的<a id="id458" class="indexterm"/>步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">定义一个包含输出属性<div> <pre class="programlisting">dtClust &lt;- dtBank[, 'output', with = F]</pre> </div>的数据表<a id="id459" class="indexterm"/></li><li class="listitem">向数据表中添加两个定义分类的列。每列对应不同数量的簇:<div> <pre class="programlisting">dtClust[, clusterHc1 := cutree(hclOut, k = k1)] dtClust[, clusterHc2 := cutree(hclOut, k = k2)]</pre> </div></li><li class="listitem">用一行三列定义绘图布局。<code class="literal">oma</code>参数定义了外部边距:<div> <pre class="programlisting">par(mfrow = c(1, 3), oma = c(0, 0, 10, 0))</pre> </div></li><li class="listitem">使用类似于数据探索的命令，构建三个直方图，显示订阅或未订阅每个集群的客户端的百分比:<div> <pre class="programlisting">for(iCluster in 1:k1){   tableClust &lt;- dtClust[     clusterHc1 == iCluster,     table(output)     ]   sizeCluster &lt;- dtClust[, sum(clusterHc1 == iCluster)]   titlePie &lt;- paste(sizeCluster, 'clients')   barplot(     height = tableClust,     names.arg = defPercentage(tableClust),     legend.text = c('no', 'yes'),     col = c('blue', 'red'),     main = titlePie   ) }</pre> </div></li><li class="listitem">添加图表的标题:<div> <pre class="programlisting">mtext(   text = 'Hierarchic clustering, n = 3',   outer = TRUE, line = 1, cex = 2 )</pre> </div></li></ol></div><p>获得的直方图<a id="id460" class="indexterm"/>如下:</p><div><img src="img/7740OS_08_08.jpg" alt="Clustering the clients"/></div><p>第一个和第二个集群包含了大部分客户，该活动在他们身上并不特别成功。第三个集群较小，其客户端订阅的百分比明显较高。然后，我们可以开始针对新客户的营销活动，类似于第三个集群。</p><p>使用相同的R命令，我们可以看到由第二次分割确定的七个集群的相同图表，如下所示:</p><div><ol class="orderedlist arabic"><li class="listitem">定义两行四列的绘图布局:<div> <pre class="programlisting">par(mfrow = c(2, 4), oma = c(0, 0, 10, 0))</pre> </div></li><li class="listitem">构建直方图:<div> <pre class="programlisting">for(iCluster in 1:k2){   tableClust &lt;- dtClust[     clusterHc2 == iCluster,     table(output)     ]   sizeCluster &lt;- dtClust[, sum(clusterHc2 == iCluster)]   titlePie &lt;- paste(sizeCluster, 'clients')   barplot(     height = tableClust,     names.arg = defPercentage(tableClust),     col = c('blue', 'red'),     main = titlePie   ) }</pre> </div></li><li class="listitem">添加<a id="id461" class="indexterm"/>图表标题:<div> <pre class="programlisting">mtext(   text = 'Hierarchic clustering, n = 7',   outer = TRUE, line = 1, cex = 2 )</pre> </div></li></ol></div><p>得到的直方图<a id="id462" class="indexterm"/>如下:</p><div><img src="img/7740OS_08_09.jpg" alt="Clustering the clients"/></div><p>前三个集群包含了大部分客户，营销活动对他们来说并不是特别有效。第四个和第五个集群的客户端订阅比例要高得多。最后两个集群非常成功，尽管它们非常小。营销活动将开始针对所有新客户，类似于最后两个集群，它将针对第四和第五集群的一部分客户。</p><p>总之，通过聚类，我们发现了活动非常成功的小客户群体。然而，大多数客户属于一个<a id="id464" class="indexterm"/>大集群，我们没有足够的信息。原因是该活动在少数具有特定特征的客户身上取得了成功。</p></div>





<title>Predicting the output</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch08lvl1sec45"/>预测产量</h1></div></div></div><p>过去的营销<a id="id465" class="indexterm"/>活动针对的是部分客户群。在其他1000个客户中，我们如何确定100个更热衷于订阅？我们可以建立一个模型，从数据中学习，并估计哪些客户与之前活动中订阅的客户更相似。对于每个客户端，如果该客户端更有可能订阅，则该模型估计得分较高。有不同的机器学习模型来确定分数，我们使用两种性能良好的技术，如下所示:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>逻辑回归</strong>:这是线性回归的一个变体，用于预测二进制<a id="id466" class="indexterm"/>输出</li><li class="listitem" style="list-style-type: disc"><strong>随机森林</strong>:这是一个<a id="id467" class="indexterm"/>基于决策树的集成，在存在许多特征的情况下工作良好</li></ul></div><p>最后，我们需要从两种技术中选择一种。交叉验证方法允许我们评估模型的准确性(参见<a class="link" href="ch06.html" title="Chapter 6. Step 3 – Validating the Results">第6章</a>、<em>步骤3-验证结果</em>)。从这一点出发，我们可以衡量两个选项的准确性，并选择一个表现更好的选项。</p><p>在选择了最合适的机器学习算法后，我们可以使用交叉验证来优化它。然而，为了避免模型构建过于复杂，我们不执行任何特征选择或参数优化。</p><p>以下是<a id="id468" class="indexterm"/>构建和评估模型的步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">加载包含随机森林算法的<code class="literal">randomForest</code>包:<div> <pre class="programlisting">library('randomForest')</pre> </div></li><li class="listitem">定义定义输出和变量名的公式。公式格式为<code class="literal">output ~ feature1 + feature2 + ...</code> : <div> <pre class="programlisting">arrayFeatures &lt;- names(dtBank) arrayFeatures &lt;- arrayFeatures[arrayFeatures != 'output'] formulaAll &lt;- paste('output', '~') formulaAll &lt;- paste(formulaAll, arrayFeatures[1]) for(nameFeature in arrayFeatures[-1]){   formulaAll &lt;- paste(formulaAll, '+', nameFeature) } formulaAll &lt;- formula(formulaAll)</pre> </div></li><li class="listitem">初始化包含所有测试集的表格:<div> <pre class="programlisting">dtTestBinded &lt;- data.table()</pre> </div></li><li class="listitem">定义迭代次数:<div> <pre class="programlisting">nIter &lt;- 10</pre> </div></li><li class="listitem">开始一个<code class="literal">for</code>循环:<div> <pre class="programlisting">for(iIter in 1:nIter) {</pre> </div></li><li class="listitem">定义训练和测试数据集:<div> <pre class="programlisting">indexTrain &lt;- sample(   x = c(TRUE, FALSE),   size = nrow(dtBank),   replace = T,   prob = c(0.8, 0.2) ) dtTrain &lt;- dtBank[indexTrain] dtTest &lt;- dtBank[!indexTrain]</pre> </div></li><li class="listitem">从测试集中选择一个子集，使我们拥有相同数量的<code class="literal">output == 0</code>和<code class="literal">output == 1</code>。首先，我们根据输出将<code class="literal">dtTest</code>分成两部分(<code class="literal">dtTest0</code>和<code class="literal">dtTest1</code>)，并计算每个部分的行数(<code class="literal">n0</code>和<code class="literal">n1</code>)。然后，由于<code class="literal">dtTest0</code>有更多的行，我们随机选择<code class="literal">n1</code>行。最后，我们重新定义<code class="literal">dtTest</code>绑定<code class="literal">dtTest0</code>和<code class="literal">dtTest1</code>，如下:<div> <pre class="programlisting">  dtTest1 &lt;- dtTest[output == 1]   dtTest0 &lt;- dtTest[output == 0]   n0 &lt;- nrow(dtTest0)   n1 &lt;- nrow(dtTest1)   dtTest0 &lt;- dtTest0[sample(x = 1:n0, size = n1)]   dtTest &lt;- rbind(dtTest0, dtTest1)</pre> </div></li><li class="listitem">使用<code class="literal">randomForest</code>建立随机森林模型。公式参数定义变量之间的<a id="id469" class="indexterm"/>关系，数据参数定义训练数据集。为了避免模型过于复杂，所有其他参数都保留默认值:<div> <pre class="programlisting">modelRf &lt;- randomForest(   formula = formulaAll,   data = dtTrain )</pre> </div></li><li class="listitem">使用<code class="literal">glm</code>建立逻辑回归模型，该函数用于建立<strong>广义线性模型</strong> ( <strong> GLM </strong>)。GLMs是线性回归的推广，允许定义连接线性<a id="id470" class="indexterm"/>预测器和输出的链接函数。输入与随机森林相同，增加了<code class="literal">family = binomial(logit)</code>定义回归为逻辑:<div> <pre class="programlisting">modelLr &lt;- glm(   formula = formulaAll,   data = dtTest,   family = binomial(logit) )</pre> </div></li><li class="listitem">预测随机森林的输出。该函数为<code class="literal">predict</code>，其主要参数为<code class="literal">object</code>定义模型和<code class="literal">newdata</code>定义测试集，如下:<div> <pre class="programlisting">dtTest[, outputRf := predict(   object = modelRf, newdata = dtTest, type='response'   )]</pre> </div></li><li class="listitem">使用类似于随机森林的<code class="literal">predict</code>预测逻辑回归的输出。另一个论点是<code class="literal">type='response'</code>并且在逻辑回归的情况下是必要的:<div> <pre class="programlisting">dtTest[, outputLr := predict(   object = modelLr, newdata = dtTest, type='response'   )]</pre> </div></li><li class="listitem">将新的测试集添加到<code class="literal">dtTestBinded</code> : <div> <pre class="programlisting">dtTestBinded &lt;- rbind(dtTestBinded, dtTest)</pre> </div></li><li class="listitem">结束<code class="literal">for</code>循环:<div> <pre class="programlisting">}</pre> </div></li></ol></div><p>我们构建了包含<code class="literal">output</code>列的<code class="literal">dtTestBinded</code>,该列定义了哪些客户进行了订阅以及模型估计的分数。将分数与真实输出进行比较，可以验证模型的性能。</p><p>为了探究<code class="literal">dtTestBinded</code>，我们可以构建一个图表，显示非订阅客户端的分数是如何分布的。然后，我们将订阅客户端的分布添加到图表中，并对它们进行比较。这样就可以看出两组分数的差异。由于我们对随机森林和逻辑回归使用相同的图表，我们<a id="id471" class="indexterm"/>通过以下给定步骤定义一个构建图表的函数:</p><div><ol class="orderedlist arabic"><li class="listitem">定义函数及其输入，包括数据表和分数列的名称:<div> <pre class="programlisting">plotDistributions &lt;- function(dtTestBinded, colPred) {</pre> </div></li><li class="listitem">计算没有订阅的客户端的分布密度。使用<code class="literal">output == 0</code>，我们提取未订阅的客户端，使用<code class="literal">density</code>，我们定义一个<code class="literal">density</code>对象。调整参数定义平滑带宽，它是我们从数据开始构建曲线的方式的参数。带宽可以解释为详细程度:<div> <pre class="programlisting">  densityLr0 &lt;- dtTestBinded[     output == 0,     density(get(colPred), adjust = 0.5)     ]</pre> </div></li><li class="listitem">计算订阅客户端的分布密度:<div> <pre class="programlisting">  densityLr1 &lt;- dtTestBinded[     output == 1,     density(get(colPred), adjust = 0.5)     ]</pre> </div></li><li class="listitem">使用<code class="literal">rgb</code>定义图表中的颜色。颜色有透明红和透明蓝:<div> <pre class="programlisting">  col0 &lt;- rgb(1, 0, 0, 0.3)   col1 &lt;- rgb(0, 0, 1, 0.3)</pre> </div></li><li class="listitem">使用未订阅的客户端密度构建图表。这里，<code class="literal">polygon</code>是将面积加到图表上的函数:<div> <pre class="programlisting">  plot(densityLr0, xlim = c(0, 1), main = 'density')   polygon(densityLr0, col = col0, border = 'black')</pre> </div></li><li class="listitem">添加订阅图表的客户端:<div> <pre class="programlisting">  polygon(densityLr1, col = col1, border = 'black')</pre> </div></li><li class="listitem">添加<a id="id472" class="indexterm"/>图例:<div> <pre class="programlisting">  legend(     'top',     c('0', '1'),     pch = 16,     col = c(col0, col1)   )</pre> </div></li><li class="listitem">结束功能:<div> <pre class="programlisting">  return() }</pre> </div></li></ol></div><p>现在，我们可以对随机森林输出使用<code class="literal">plotDistributions</code>:</p><div><pre class="programlisting">par(mfrow = c(1, 1))
plotDistributions(dtTestBinded, 'outputRf')</pre></div><p>获得的直方图如下:</p><div><img src="img/7740OS_08_10.jpg" alt="Predicting the output"/></div><p>x轴代表分数，y轴代表与订阅相似分数的客户端数量成比例的密度。由于我们没有每个可能分数的客户端，假设细节级别为0.01，密度曲线是平滑的，即每个分数的密度是具有相似分数的数据之间的平均值。</p><p>红色和蓝色区域分别代表非订阅客户端和订阅客户端。很容易注意到，紫色区域来自两条曲线的重叠。对于每个分数，我们可以确定哪个密度更高。如果最高的曲线是红色的，客户端将更有可能订阅，反之亦然。</p><p>对于随机森林，大多数非订阅客户分数在<code class="literal">0</code>和<code class="literal">0.2</code>之间，密度峰值在<code class="literal">0.05</code>附近的<a id="id473" class="indexterm"/>。订阅客户有一个更大的价差分数，虽然更高，并且他们的峰值在<code class="literal">0.1</code>左右。这两个发行版有很多重叠，所以很难从他们的分数来确定哪些客户会订阅。但是，如果营销活动的目标是得分高于0.3的所有客户，他们将可能属于蓝色聚类。总之，使用random forest，我们能够确定一小组很有可能订阅的客户。</p><p>为了进行比较，我们可以构建关于逻辑回归输出的相同图表，如下所示:</p><div><pre class="programlisting">plotDistributions(dtTestBinded, 'outputLr')</pre></div><p>获得的直方图<a id="id474" class="indexterm"/>如下:</p><div><img src="img/7740OS_08_11.jpg" alt="Predicting the output"/></div><p>对于逻辑回归，两个分布有点重叠，但它们明显覆盖了两个不同的区域，并且它们的峰值非常远。分数高于0.8的客户很可能会订阅，所以我们可以选择一小部分客户。如果我们选择得分在0.5或0.6以上的客户，我们也能够确定更多可能订阅的客户。</p><p>总之，逻辑回归似乎表现得更好。然而，分布图只适合于探索性能，而不能提供清晰的评估。下一步是定义如何使用索引评估模型。</p><p>我们将使用的<a id="id475" class="indexterm"/>验证指标是AUC，它取决于另一个图表，即<strong>受试者操作特征</strong> ( <strong> ROC </strong>)。在建立分类模型之后，我们定义一个阈值，并假设分数高于该阈值的客户将会订阅。ROC显示了依赖于阈值的模型准确性。曲线尺寸为:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>真实阳性率</strong>:该指标显示在订阅客户中，得分高于阈值的百分比<a id="id476" class="indexterm"/>。这个指数要尽可能的高。</li><li class="listitem" style="list-style-type: disc"><strong>误报率</strong>:该指标显示在非订阅客户中，<a id="id477" class="indexterm"/>百分比得分高于阈值。这个指数应该尽可能的低。</li></ul></div><p>曲线 ( <strong> AUC </strong>)下的<strong>面积是ROC下的面积。给定订阅的随机客户端和未订阅的另一个随机客户端，AUC表示订阅的客户端的分数高于另一个客户端的概率。</strong></p><p>我们可以定义一个函数<a id="id479" class="indexterm"/>来构建图表并计算AUC指数:</p><div><ol class="orderedlist arabic"><li class="listitem">加载包含用于交叉验证模型的函数的<code class="literal">ROCR</code>包:<div> <pre class="programlisting">library('ROCR')</pre> </div></li><li class="listitem">定义函数及其输入，包括数据表和分数列的名称:<div> <pre class="programlisting">plotPerformance &lt;- function(dtTestBinded, colPred) {</pre> </div></li><li class="listitem">定义一个预测对象，作为构建ROC图表的起点。该功能为<code class="literal">prediction</code>，由<code class="literal">ROCR</code>包提供:<div> <pre class="programlisting">  pred &lt;- dtTestBinded[, prediction(get(colPred), output)]</pre> </div></li><li class="listitem">构建ROC图表。<code class="literal">ROCR</code>包提供的函数是<code class="literal">performance</code>，它允许你以不同的方式评估预测。在这种情况下，我们<a id="id480" class="indexterm"/>想要用<code class="literal">true</code>和<code class="literal">false</code>的阳性率构建一个图表，所以输入是<strong>真阳性率</strong> ( <strong> tpr </strong>)和<strong>假阳性率</strong>(<strong>FPR</strong>):<div><pre class="programlisting">  perfRates &lt;- performance(pred, 'tpr', 'fpr')   plot(perfRates)</pre></div></li><li class="listitem">使用<code class="literal">performance</code>计算AUC指数。输入是<code class="literal">auc</code>，它定义我们正在计算AUC指数:<div> <pre class="programlisting">  perfAuc &lt;- performance(pred, 'auc')   auc &lt;- perfAuc@y.values[[1]]</pre> </div></li><li class="listitem">返回AUC指数作为函数输出:<div> <pre class="programlisting">  return(auc) }</pre> </div></li></ol></div><p>使用<code class="literal">plotPerformance</code>，我们可以构建关于随机森林的图表，并计算存储在<code class="literal">aucRf</code>中的<code class="literal">auc</code>索引:</p><div><pre class="programlisting">aucRf &lt;- plotPerformance(dtTestBinded, 'outputRf')</pre></div><p>获得的直方图如下:</p><div><img src="img/7740OS_08_13.jpg" alt="Predicting the output"/></div><p>正如预期的那样，图表分别显示了tpr和fpr。当阈值为<code class="literal">1</code>时，没有客户端的速率高于它，因此没有正的(预测订阅的客户端)。在这种情况下，我们处于右上角，两个指数都等于100%。随着<a id="id482" class="indexterm"/>阈值的降低，我们有了更多的积极客户，因此tpr和fpr降低。最终，当阈值为<code class="literal">0</code>时，tpr和fpr等于<code class="literal">0</code>，我们在左下角。在理想情况下，tpr等于<code class="literal">1</code>，fpr等于<code class="literal">0</code>(左上角)。然后，曲线越靠近左上角越好。</p><p>与随机森林相似，我们为逻辑回归构建图表并计算AUC指数:</p><div><pre class="programlisting">aucLr &lt;- plotPerformance(dtTestBinded, 'outputLr')</pre></div><p>获得的直方图如下:</p><div><img src="img/7740OS_08_14.jpg" alt="Predicting the output"/></div><p>逻辑回归的图表类似于随机森林的图表。查看详细信息，我们可以注意到左下方的曲线更陡，而右上方的曲线不太陡，因此定义AUC的曲线下面积更大。</p><p>交叉验证包含随机成分，因此AUC指数可能略有不同。设置<code class="literal">nIter = 100</code>，上次我执行脚本时，随机森林的AUC大约为73 %,逻辑回归的AUC大约为79%。我们可以得出结论，逻辑回归表现更好，所以我们应该使用它来建立模型。</p><p>在本节中，我们学习了如何构建一个为客户提供分数的模型。该算法允许<a id="id483" class="indexterm"/>公司识别更有可能订阅的客户，并且还可以估计其准确性。本章的后续部分将选择一个特征子集并优化参数，以便获得更好的性能。</p></div>





<title>Summary</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch08lvl1sec46"/>摘要</h1></div></div></div><p>在本章中，您学习了如何探索和转换与业务问题相关的数据。您使用聚类技术来划分银行的客户群，并使用监督学习技术来确定客户的得分排名。在建立机器学习模型后，您能够交叉验证它，可视化ROC曲线并计算AUC指数。这样，你就能够选择最合适的技术。</p><p>这本书展示了机器学习模型如何解决商业问题。这本书不仅仅是一个教程，它还展示了机器学习的重要性，如何开发解决方案，以及如何使用这些技术解决业务问题。我希望这本书不仅传递了机器学习的概念，还传递了对这个既有价值又迷人的领域的热情。我要感谢你遵循这条道路。我希望这只是一段美好旅程的开始。</p><p>如果你有任何疑问，请不要犹豫与我联系。</p></div>
</body></html>